<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最后的Typora免费版本</title>
      <link href="/2022/10/25/%E6%9C%80%E5%90%8E%E7%9A%84Typora%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC/"/>
      <url>/2022/10/25/%E6%9C%80%E5%90%8E%E7%9A%84Typora%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>转自:<a href="https://zahui.fan/posts/64b52e0d/">最后一个Typora免费版0.11.18</a></p><ul><li><a href="https://github.com/iuxt/src/releases/download/2.0/typora-0-11-18.exe">Windows</a></li><li><a href="https://github.com/iuxt/src/releases/download/2.0/typora-0-11-18.dmg">Mac</a></li><li><a href="https://github.com/iuxt/src/releases/download/2.0/Typora_Linux_0.11.18_amd64.deb">Ubuntu</a></li><li><a href="https://github.com/iuxt/src/releases/download/2.0/typora-0-11-18.tar.gz">其他Linux (非debian)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark之基础概念</title>
      <link href="/2022/10/25/Spark%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/10/25/Spark%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>基于内存，分布式计算，函数式处理</p><h1 id="RDD：Resilient-Distributed-Dataset"><a href="#RDD：Resilient-Distributed-Dataset" class="headerlink" title="RDD：Resilient Distributed Dataset"></a>RDD：Resilient Distributed Dataset</h1><p>弹性分布式数据集：不可变，分布式抽象数据。使用时可以显示的将其换存在内存中以提高速度</p><ul><li>分片，每一个分片会被一个计算任务处理，可以在创建RDD时指定分片数</li><li>迭代器，每个分片计算结果可以通过迭代器的compute函数进行整合，无需保存每次计算的结果</li><li>依赖关系，RDD转换后形成新的RDD，新的RDD就依赖之前的结果。在部分分区计算失败或数据丢失时，可以具体到依赖的分区进行重新计算即可</li><li>分片函数，哈希分片语范围分片，其决定了分片数量</li><li>移动计算而不是移动数据，任务调度时尽可能将任务下发到所需处理的数据块存储节点执行</li></ul><h1 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h1><ul><li>HDFS</li><li>数据库</li><li>本地文件</li><li>其他</li></ul><h1 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h1><ul><li><p>Transformation</p><p>将一个RDD转换为另一个RDD，transfromation具有lazy load特性。需要遇到action算子时才会执行</p><table><thead><tr><th><strong>Transformation</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>map</strong>(func)</td><td>返回一个新的RDD，该RDD由每一个输入元素经过func函数转换后组成</td></tr><tr><td><strong>filter</strong>(func)</td><td>返回一个新的RDD，该RDD由经过func函数计算后返回值为true的输入元素组成</td></tr><tr><td><strong>flatMap</strong>(func)</td><td>类似于map，但是每一个输入元素可以被映射为0或多个输出元素（所以func应该返回一个序列，而不是单一元素）</td></tr><tr><td><strong>mapPartitions</strong>(func)</td><td>类似于map，但独立地在RDD的每一个分片上运行，因此在类型为T的RDD上运行时，func的函数类型必须是Iterator[T] &#x3D;&gt; Iterator[U]</td></tr><tr><td><strong>mapPartitionsWithIndex</strong>(func)</td><td>类似于mapPartitions，但func带有一个整数参数表示分片的索引值，因此在类型为T的RDD上运行时，func的函数类型必须是(Int, Interator[T]) &#x3D;&gt; Iterator[U]</td></tr><tr><td><strong>sample</strong>(withReplacement, fraction, seed)</td><td>根据fraction指定的比例对数据进行采样，可以选择是否使用随机数进行替换，seed用于指定随机数生成器种子</td></tr><tr><td><strong>union</strong>(otherDataset)</td><td>对源RDD和参数RDD求并集后返回一个新的RDD</td></tr><tr><td><strong>intersection</strong>(otherDataset)</td><td>对源RDD和参数RDD求交集后返回一个新的RDD</td></tr><tr><td><strong>distinct</strong>([numTasks]))</td><td>对源RDD进行去重后返回一个新的RDD</td></tr><tr><td><strong>groupByKey</strong>([numTasks])</td><td>在一个(K,V)的RDD上调用，返回一个(K, Iterator[V])的RDD</td></tr><tr><td><strong>reduceByKey</strong>(func, [numTasks])</td><td>在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用指定的reduce函数，将相同key的值聚合到一起，与groupByKey类似，reduce任务的个数可以通过第二个可选的参数来设置</td></tr><tr><td><strong>aggregateByKey</strong>(zeroValue)(seqOp, combOp, [numTasks])</td><td>先按分区聚合 再总的聚合  每次要跟初始值交流 例如：aggregateByKey(0)(<em>+</em>,<em>+</em>) 对k&#x2F;y的RDD进行操作</td></tr><tr><td><strong>sortByKey</strong>([ascending], [numTasks])</td><td>在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD</td></tr><tr><td><strong>sortBy</strong>(func,[ascending], [numTasks])</td><td>与sortByKey类似，但是更灵活 第一个参数是根据什么排序 第二个是怎么排序 false倒序  第三个排序后分区数 默认与原RDD一样</td></tr><tr><td><strong>join</strong>(otherDataset, [numTasks])</td><td>在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD 相当于内连接（求交集）</td></tr><tr><td><strong>cogroup</strong>(otherDataset, [numTasks])</td><td>在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的RDD</td></tr><tr><td><strong>cartesian</strong>(otherDataset)</td><td>两个RDD的笛卡尔积 的成很多个K&#x2F;V</td></tr><tr><td><strong>pipe</strong>(command, [envVars])</td><td>调用外部程序</td></tr><tr><td><strong>coalesce</strong>(numPartitions**)**</td><td>重新分区 第一个参数是要分多少区，第二个参数是否shuffle 默认false 少分区变多分区 true  多分区变少分区 false</td></tr><tr><td><strong>repartition</strong>(numPartitions)</td><td>重新分区 必须shuffle 参数是要分多少区 少变多</td></tr><tr><td><strong>repartitionAndSortWithinPartitions</strong>(partitioner)</td><td>重新分区+排序 比先分区再排序效率高 对K&#x2F;V的RDD进行操作</td></tr><tr><td><strong>foldByKey</strong>(zeroValue)(seqOp)</td><td>该函数用于K&#x2F;V做折叠，合并处理 ，与aggregate类似  第一个括号的参数应用于每个V值 第二括号函数是聚合例如：_+_</td></tr><tr><td><strong>combineByKey</strong></td><td>合并相同的key的值 rdd1.combineByKey(x &#x3D;&gt; x, (a: Int, b: Int) &#x3D;&gt; a + b, (m: Int, n: Int) &#x3D;&gt; m + n)</td></tr><tr><td><strong>partitionBy****（partitioner）</strong></td><td>对RDD进行分区 partitioner是分区器 例如new HashPartition(2</td></tr><tr><td><strong>cache</strong></td><td>RDD缓存，可以避免重复计算从而减少时间，区别：cache内部调用了persist算子，cache默认就一个缓存级别MEMORY-ONLY ，而persist则可以选择缓存级别</td></tr><tr><td><strong>persist</strong></td><td></td></tr><tr><td></td><td></td></tr><tr><td><strong>Subtract****（rdd）</strong></td><td>返回前rdd元素不在后rdd的rdd</td></tr><tr><td><strong>leftOuterJoin</strong></td><td>leftOuterJoin类似于SQL中的左外关联left outer join，返回结果以前面的RDD为主，关联不上的记录为空。只能用于两个RDD之间的关联，如果要多个RDD关联，多关联几次即可。</td></tr><tr><td><strong>rightOuterJoin</strong></td><td>rightOuterJoin类似于SQL中的有外关联right outer join，返回结果以参数中的RDD为主，关联不上的记录为空。只能用于两个RDD之间的关联，如果要多个RDD关联，多关联几次即可</td></tr><tr><td>subtractByKey</td><td>substractByKey和基本转换操作中的subtract类似只不过这里是针对K的，返回在主RDD中出现，并且不在otherRDD中出现的元素</td></tr></tbody></table></li><li><p>Action</p><p>触发代码执行，一段spark代码至少需要一个action</p><table><thead><tr><th><strong>Action</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>reduce</strong>(<em>func</em>)</td><td>通过func函数聚集RDD中的所有元素，这个功能必须是课交换且可并联的</td></tr><tr><td><strong>collect</strong>()</td><td>在驱动程序中，以数组的形式返回数据集的所有元素</td></tr><tr><td><strong>count</strong>()</td><td>返回RDD的元素个数</td></tr><tr><td><strong>first</strong>()</td><td>返回RDD的第一个元素（类似于take(1)）</td></tr><tr><td><strong>take</strong>(<em>n</em>)</td><td>返回一个由数据集的前n个元素组成的数组</td></tr><tr><td><strong>takeSample</strong>(<em>withReplacement</em>,<em>num</em>, [<em>seed</em>])</td><td>返回一个数组，该数组由从数据集中随机采样的num个元素组成，可以选择是否用随机数替换不足的部分，seed用于指定随机数生成器种子</td></tr><tr><td><strong>takeOrdered</strong>(<em>n</em>, <em>[ordering]</em>)</td><td></td></tr><tr><td><strong>saveAsTextFile</strong>(<em>path</em>)</td><td>将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本</td></tr><tr><td><strong>saveAsSequenceFile</strong>(<em>path</em>)</td><td>将数据集中的元素以Hadoop sequencefile的格式保存到指定的目录下，可以使HDFS或者其他Hadoop支持的文件系统。</td></tr><tr><td><strong>saveAsObjectFile</strong>(<em>path</em>)</td><td></td></tr><tr><td><strong>countByKey</strong>()</td><td>针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。</td></tr><tr><td><strong>foreach</strong>(<em>func</em>)</td><td>在数据集的每一个元素上，运行函数func进行更新。</td></tr><tr><td><strong>aggregate</strong></td><td>先对分区进行操作，在总体操作</td></tr><tr><td><strong>reduceByKeyLocally</strong></td><td></td></tr><tr><td><strong>lookup</strong></td><td></td></tr><tr><td><strong>top</strong></td><td></td></tr><tr><td><strong>fold</strong></td><td></td></tr><tr><td><strong>foreachPartition</strong></td><td></td></tr></tbody></table></li></ul><h1 id="Spark任务基础概念"><a href="#Spark任务基础概念" class="headerlink" title="Spark任务基础概念"></a>Spark任务基础概念</h1><ul><li><p>Application</p><p>driver程序以及集群执行的代码</p></li><li><p>driver</p><p>创建sc，加载数据集，处理数据以及展示流程</p></li><li><p>集群节点</p><p>driver：创建sc，启动spark级集群计算任务</p><p>master：master节点</p><p>worker：集群任务执行节点，启动executor进程</p><p>Executor：执行应用程序以及汇报执行状态</p><p>cluster manager：集群资源管理器，负责申请资源调度任务，如yarn</p></li><li><p>jobs</p><p>RDD中的action，每个action变为一个job，然后DAGScheduler回分解stage执行</p></li><li><p>stage</p><p>一个job拆分为多组task，每组是一个stage</p></li><li><p>task</p><p>送到executor执行的工作单元，两类：shuffleMapTask：输出shffle所需要的数据；resultTask：无需shuffle直接返回处理结果</p></li><li><p>partition</p><p>数据划分</p></li><li><p>cores</p><p>worker执行进程</p></li><li><p>memory</p><p>内存设置</p></li><li><p>shuffle</p><p>stage之间的数据拷贝</p></li></ul><h1 id="窄依赖与宽依赖"><a href="#窄依赖与宽依赖" class="headerlink" title="窄依赖与宽依赖"></a>窄依赖与宽依赖</h1><p>窄依赖：每个RDD只会被一个子RDD所依赖，例如map、filter、union等操作都会产生窄依赖；（独生子女）</p><p>宽依赖：每个RDD被多个子RDD所依赖，例如groupByKey、reduceByKey、sortByKey等操作都会产生宽依赖；（超生）</p><p>关于join的依赖关系：</p><p>两个RDD在进行join操作时，一个RDD的partition仅仅和另一个RDD中已知个数的Partition进行join，那么这种类型的join操作就是窄依赖。否则就是宽依赖。</p><h1 id="DAG图与宽窄依赖"><a href="#DAG图与宽窄依赖" class="headerlink" title="DAG图与宽窄依赖"></a>DAG图与宽窄依赖</h1><p>DAGScheduler遇到action job时，会根据宽窄依赖决定stage划分。如果遇到窄依赖会将该action加入当前stage，遇到宽依赖则创建新的stage去执行</p>]]></content>
      
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git commit message specification</title>
      <link href="/2022/10/25/Git-commit-message-specification/"/>
      <url>/2022/10/25/Git-commit-message-specification/</url>
      
        <content type="html"><![CDATA[<p>Git commit message specification</p><p><a href="https://www.conventionalcommits.org/en/v1.0.0/">https://www.conventionalcommits.org/en/v1.0.0/</a></p><p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a></p><h1 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h1><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;[optional scope]: &lt;description&gt;</span><br><span class="line"></span><br><span class="line">[optional body]</span><br><span class="line"></span><br><span class="line">[optional footer(s)]</span><br></pre></td></tr></table></figure><p>Types:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">abaliable types:</span><br><span class="line">[</span><br><span class="line">  &#x27;build&#x27;,</span><br><span class="line">  &#x27;chore&#x27;,</span><br><span class="line">  &#x27;ci&#x27;,</span><br><span class="line">  &#x27;docs&#x27;,</span><br><span class="line">  &#x27;feat&#x27;,</span><br><span class="line">  &#x27;fix&#x27;,</span><br><span class="line">  &#x27;perf&#x27;,</span><br><span class="line">  &#x27;refactor&#x27;,</span><br><span class="line">  &#x27;revert&#x27;,</span><br><span class="line">  &#x27;style&#x27;,</span><br><span class="line">  &#x27;test&#x27;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">description:</span><br><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="Commit-message-with-description-and-breaking-change-footer"><a href="#Commit-message-with-description-and-breaking-change-footer" class="headerlink" title="Commit message with description and breaking change footer"></a>Commit message with description and breaking change footer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feat: allow provided config object to extend other configs</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: `extends` key in config file is now used for extending other config files</span><br></pre></td></tr></table></figure><h3 id="Commit-message-with-to-draw-attention-to-breaking-change"><a href="#Commit-message-with-to-draw-attention-to-breaking-change" class="headerlink" title="Commit message with ! to draw attention to breaking change"></a>Commit message with <code>!</code> to draw attention to breaking change</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat!: send an email to the customer when a product is shipped</span><br></pre></td></tr></table></figure><h3 id="Commit-message-with-scope-and-to-draw-attention-to-breaking-change"><a href="#Commit-message-with-scope-and-to-draw-attention-to-breaking-change" class="headerlink" title="Commit message with scope and ! to draw attention to breaking change"></a>Commit message with scope and <code>!</code> to draw attention to breaking change</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat(api)!: send an email to the customer when a product is shipped</span><br></pre></td></tr></table></figure><h3 id="Commit-message-with-both-and-BREAKING-CHANGE-footer"><a href="#Commit-message-with-both-and-BREAKING-CHANGE-footer" class="headerlink" title="Commit message with both ! and BREAKING CHANGE footer"></a>Commit message with both <code>!</code> and BREAKING CHANGE footer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chore!: drop support for Node 6</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: use JavaScript features not available in Node 6.</span><br></pre></td></tr></table></figure><h3 id="Commit-message-with-no-body"><a href="#Commit-message-with-no-body" class="headerlink" title="Commit message with no body"></a>Commit message with no body</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs: correct spelling of CHANGELOG</span><br></pre></td></tr></table></figure><h3 id="Commit-message-with-scope"><a href="#Commit-message-with-scope" class="headerlink" title="Commit message with scope"></a>Commit message with scope</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat(lang): add Polish language</span><br></pre></td></tr></table></figure><h3 id="Commit-message-with-multi-paragraph-body-and-multiple-footers"><a href="#Commit-message-with-multi-paragraph-body-and-multiple-footers" class="headerlink" title="Commit message with multi-paragraph body and multiple footers"></a>Commit message with multi-paragraph body and multiple footers</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fix: prevent racing of requests</span><br><span class="line"></span><br><span class="line">Introduce a request id and a reference to latest request. Dismiss</span><br><span class="line">incoming responses other than from latest request.</span><br><span class="line"></span><br><span class="line">Remove timeouts which were used to mitigate the racing issue but are</span><br><span class="line">obsolete now.</span><br><span class="line"></span><br><span class="line">Reviewed-by: Z</span><br><span class="line">Refs: #123</span><br></pre></td></tr></table></figure><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>idea plugins: <code>git commit template</code></p><p>hangelog generate &amp; commit message validate</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> commit </tag>
            
            <tag> specification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark之广播与累加器</title>
      <link href="/2022/10/25/spark%E4%B9%8B%E5%B9%BF%E6%92%AD%E4%B8%8E%E7%B4%AF%E5%8A%A0%E5%99%A8/"/>
      <url>/2022/10/25/spark%E4%B9%8B%E5%B9%BF%E6%92%AD%E4%B8%8E%E7%B4%AF%E5%8A%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p>如果我们要在分布式计算里面分发大对象，例如：字典，集合，黑白名单等，这个都会由Driver端进行分发，一般来讲，如果这个变量不是广播变量，那么每个task就会分发一份，这在<strong>task数目十分多的情况下Driver的带宽会成为系统的瓶颈，而且会大量消耗task服务器上的资源</strong>，如果将这个变量声明为广播变量，那么知识每个executor拥有一份，这个executor启动的task会共享这个变量，节省了通信的成本和服务器的资源。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># create</span><br><span class="line"><span class="keyword">val</span> a = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> broadcast = sc.broadcast(a)</span><br><span class="line"></span><br><span class="line"># use</span><br><span class="line"><span class="keyword">val</span> c = broadcast.value</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、能不能将一个RDD使用广播变量广播出去？</p><pre><code>不能，因为RDD是不存储数据的。**可以将RDD的结果广播出去。**</code></pre><p>2、 广播变量只能在Driver端定义，<strong>不能在Executor端定义。</strong></p><p>3、 在Driver端可以修改广播变量的值，<strong>在Executor端无法修改广播变量的值。</strong></p><p>4、如果executor端用到了Driver的变量，如果<strong>不使用广播变量在Executor有多少task就有多少Driver端的变量副本。</strong></p><p>5、如果Executor端用到了Driver的变量，如果<strong>使用广播变量在每个Executor中只有一份Driver端的变量副本。</strong></p><h1 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h1><p>在spark应用程序中，我们经常会有这样的需求，如异常监控，调试，记录符合某特性的数据的数目，这种需求都需要用到计数器，如果一个变量不被声明为一个累加器，那么它将在被改变时不会再driver端进行全局汇总，即在分布式运行时每个task运行的只是原始变量的一个副本，并不能改变原始变量的值，但是当这个变量被声明为累加器后，该变量就会有分布式计数的功能。</p><h2 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># create</span><br><span class="line"><span class="keyword">val</span> a = sc.accumulator(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"># use</span><br><span class="line"><span class="keyword">val</span> b = a.value</span><br></pre></td></tr></table></figure><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p>累加器在Driver端定义赋初始值，累加器只能在Driver端读取最后的值，在Excutor端更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> broadcast </tag>
            
            <tag> accumulator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装shadowsocks并开启全局代理</title>
      <link href="/2022/10/25/Linux-%E5%AE%89%E8%A3%85shadowsocks%E5%B9%B6%E5%BC%80%E5%90%AF%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"/>
      <url>/2022/10/25/Linux-%E5%AE%89%E8%A3%85shadowsocks%E5%B9%B6%E5%BC%80%E5%90%AF%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>linux安装ss客户端与kcp并开启全局代理</p><span id="more"></span><h1 id="1-安装ss客户端和kcp客户端"><a href="#1-安装ss客户端和kcp客户端" class="headerlink" title="1.安装ss客户端和kcp客户端"></a>1.安装ss客户端和kcp客户端</h1><ul><li>kcp客户端：<a href="https://github.com/xtaci/kcptun/releases">https://github.com/xtaci/kcptun/releases</a> 选择对应版本下载即可</li><li>shadowsocks客户端linux版本：<a href="https://github.com/shadowsocks/shadowsocks-rust/releases">https://github.com/shadowsocks/shadowsocks-rust/releases</a> 选择对应版本</li></ul><h1 id="2-修改配置启动kcp与ss客户端"><a href="#2-修改配置启动kcp与ss客户端" class="headerlink" title="2.修改配置启动kcp与ss客户端"></a>2.修改配置启动kcp与ss客户端</h1><h2 id="2-1-配置"><a href="#2-1-配置" class="headerlink" title="2.1 配置"></a>2.1 配置</h2><ul><li>创建kcp.json, 主要配置远程vps服务地址以及本地端口如: <code>:10080</code></li><li>创建ss.json, 配置服务地址为kcp配置的本地端口，本地端口设置如：<code>10088</code></li></ul><h2 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kcp-client -c kcp.json</span><br><span class="line">sslocal -c ss.json</span><br></pre></td></tr></table></figure><h1 id="3-开启全局代理"><a href="#3-开启全局代理" class="headerlink" title="3.开启全局代理"></a>3.开启全局代理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=&quot;socks5://代理服务器IP地址:代理端口&quot;  # 开启sock代理</span><br><span class="line">unset ALL_PROXY  # 关闭代理</span><br></pre></td></tr></table></figure><h1 id="4-使用polipo将socks代理转为http代理"><a href="#4-使用polipo将socks代理转为http代理" class="headerlink" title="4.使用polipo将socks代理转为http代理"></a>4.使用polipo将socks代理转为http代理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install polipo</span><br><span class="line">修改配置：/etc/polipo/config： 协议端口指定为socks地址</span><br><span class="line">service start polipo</span><br></pre></td></tr></table></figure><p>开启代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HTTP_PROXY=http://xxxx:xxx</span><br><span class="line">export HTTPS_PROXY=https://xxxx:xxx</span><br></pre></td></tr></table></figure><h1 id="5-开启代理后python使用requets报错"><a href="#5-开启代理后python使用requets报错" class="headerlink" title="5.开启代理后python使用requets报错"></a>5.开启代理后python使用requets报错</h1><p>错误信息：ValueError: check_hostname requires server_hostname</p><p>解决方式：降低urllib3版本至1.25.8</p>]]></content>
      
      
      
        <tags>
            
            <tag> shadowsocks </tag>
            
            <tag> kcp </tag>
            
            <tag> linux </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/25/hello-world/"/>
      <url>/2022/10/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vim 复制内容到剪切板</title>
      <link href="/2022/10/25/Vim-%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/"/>
      <url>/2022/10/25/Vim-%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 行复制：光标移动到需要复制的行，输入下面命令</span><br><span class="line">&quot;+y</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git总结</title>
      <link href="/2022/06/13/git%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/13/git%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><p>Git 一般只添加数据, 你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容;但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><span id="more"></span><p><img src="/Users/zeki/Documents/Blog/source/_posts/git%E6%80%BB%E7%BB%93/1595228461@2ffee7bd1f90f29273dadb9cb5b06440.jpg.png" alt="1595228461@2ffee7bd1f90f29273dadb9cb5b06440.jpg"></p><ul><li><p>Workspace：工作区</p></li><li><p>Index&#x2F;Stage：暂存区，也叫索引</p></li><li><p>Repository：仓库区（或本地仓库），也存储库</p></li><li><p>Remote：远程仓库</p></li></ul><p>这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 更深度探讨 Git 如何保存数据及恢复丢失数据的话题，请参考撤消操作。</p><ol><li><p>历史操作记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看历史操作记录</span></span><br><span class="line">git <span class="built_in">log</span> --oneline  <span class="comment"># 简洁版本的历史操作记录</span></span><br><span class="line">git <span class="built_in">log</span> --graph  <span class="comment"># 拓扑图选项</span></span><br><span class="line">git <span class="built_in">log</span> --reverse  <span class="comment"># 逆向显示日志</span></span><br><span class="line">git <span class="built_in">log</span> --auther=auther  <span class="comment"># 查看auther的提交</span></span><br><span class="line"><span class="comment"># 指定日期，可以执行几个选项：--since 和 --before，也可以用 --until 和 --after。</span></span><br></pre></td></tr></table></figure></li><li><p>查看当前仓库状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status  <span class="comment"># 查看当前仓库状态</span></span><br></pre></td></tr></table></figure></li><li><p>推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *  <span class="comment"># 添加至暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span>  <span class="comment"># 提交</span></span><br><span class="line">git push origin master  <span class="comment"># 推送至远程仓库master分支</span></span><br></pre></td></tr></table></figure></li><li><p>更新与拉取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://xxx.com/xxx.git  <span class="comment"># clone远程仓库</span></span><br><span class="line">git pull  <span class="comment"># 获取新更改</span></span><br></pre></td></tr></table></figure></li><li><p>暂存区保留临时更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash  <span class="comment"># 本地更改暂存 </span></span><br><span class="line">git stash list  <span class="comment"># 列出本地暂存数据</span></span><br><span class="line">git stash pop  <span class="comment"># 恢复</span></span><br></pre></td></tr></table></figure></li><li><p>移动</p><p>对于仓库的文件做移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> xxx yyy  <span class="comment"># xxx移动/重命名到yyy, git文件前显示R表示已被重命名</span></span><br><span class="line">git commit -a -m <span class="string">&quot;rename xxx to yyy&quot;</span>  <span class="comment"># -a标志，这使git commit自动检测修改的文件</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> xxx  <span class="comment"># 删除xxx文件</span></span><br><span class="line">git commit -a -m <span class="string">&quot;remove file xxx&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>todo: <a href="http://www.bjpowernode.com/tutorial_git/1775.html">http://www.bjpowernode.com/tutorial_git/1775.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown UML</title>
      <link href="/2022/06/10/Markdown-UML/"/>
      <url>/2022/06/10/Markdown-UML/</url>
      
        <content type="html"><![CDATA[<p>本文介绍如何使用Markdown绘制UML图</p><span id="more"></span><ol><li><p>创建UML类图</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">class</span>=<span class="string">&quot;mermaid&quot;</span>&gt;</span></span>   classDiagram</span><br><span class="line">// 以上为固定写法,此处开始创建对象与关系<span class="language-xml"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>类与接口</p><ul><li><p>创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramclass A {    }</pre></li><li><p>类型</p><table><thead><tr><th>符号</th><th>类型</th></tr></thead><tbody><tr><td>&lt;<interface>&gt;</td><td>接口</td></tr><tr><td>&lt;<abstract>&gt;</td><td>抽象类</td></tr><tr><td>&lt;<service>&gt;</td><td>service类</td></tr><tr><td>&lt;<enumeration>&gt;</td><td>枚举</td></tr></tbody></table><p>使用方式: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方式一：内嵌</span><br><span class="line">class A &#123;</span><br><span class="line">&lt;&lt;Interface&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式二：单独的行</span><br><span class="line">class B</span><br><span class="line">&lt;&lt;Interface&gt;&gt; B</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramclass A {    <<Interface>>}class B<<Interface>> B</pre></li><li><p>属性</p><p>两种方式内联和单独指定</p><p>方式一:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">A : +String name</span><br><span class="line">A : -int age</span><br><span class="line">A : List~Object~ child    //泛型变量</span><br><span class="line">A : +eat()</span><br><span class="line">A : +sleep(time)          //有参数的方法</span><br><span class="line">A : +getAge() int         //有返回值的方法</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramclass AA : +String nameA : -int ageA : List~Object~ child    //泛型变量A : +eat()A : +sleep(time)          //有参数的方法A : +getAge() int         //有返回值的方法</pre><p>方式二:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">    +String name</span><br><span class="line">    -int age</span><br><span class="line">    List~Object~ child</span><br><span class="line">    +eat()</span><br><span class="line">    +sleep(time)</span><br><span class="line">    +getAge() int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramclass B {    +String name    -int age    List~Object~ child    +eat()    +sleep(time)    +getAge() int}</pre><p>元素可见范围:</p><table><thead><tr><th align="left">修饰符号</th><th>可见范围</th></tr></thead><tbody><tr><td align="left">-</td><td>private</td></tr><tr><td align="left">+</td><td>public</td></tr><tr><td align="left">#</td><td>protected</td></tr><tr><td align="left">~</td><td>package</td></tr></tbody></table></li></ul></li><li><p>关系</p><ul><li><p>继承</p><p>表示子类继承父类的所有特征和行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassA &lt;|-- ClassB  // class B extends A</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramClassA <|-- ClassB</pre></li><li><p>实现</p><p>类是接口所有特征和行为的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InterfaceA &lt;|.. ClassB  // class B implements interface A</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramInterfaceA <|.. ClassB</pre></li><li><p>组合&#x2F;聚合</p><p>组合: 整体与部分的关系，但部分不能离开整体而单独存在 带实心菱形的实线，实心菱形指向整体</p><p>聚合: 整体与部分的关系，且部分可以离开整体而单独存在 带空心菱形的实现，空心菱形指向整体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassA *-- ClassB  // class B is part of A</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramClassA *-- ClassB</pre></li><li><p>关联</p><p>一个类知道另一个类的属性和方法；关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassA -- ClassB</span><br><span class="line">ClassC &lt;-- ClassD</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramClassA -- ClassBClassC <-- ClassD</pre></li><li><p>依赖</p><p>一个类的实现需要另一个类的协助</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassA &lt;.. ClassB</span><br></pre></td></tr></table></figure><pre class="mermaid">     classDiagramClassA <.. ClassB</pre></li><li><p>关系标识</p><ul><li><p>关系上添加标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassA &lt;.. ClassB : 依赖</span><br></pre></td></tr></table></figure><pre class="mermaid">       classDiagramClassA <.. ClassB : 依赖</pre></li><li><p>关系上添加数量</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>1个</td></tr><tr><td>0..1</td><td>0或1个</td></tr><tr><td>1..*</td><td>1个或多个</td></tr><tr><td>*</td><td>任意个</td></tr><tr><td>n</td><td>n个(n&gt;1)</td></tr><tr><td>0..n</td><td>0个到n个(n&gt;0)</td></tr><tr><td>1..n</td><td>1到n个(n&gt;1)</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassA &quot;1&quot; --&gt; &quot;*&quot; ClassB</span><br></pre></td></tr></table></figure><pre class="mermaid">       classDiagramClassA "1" --> "*" ClassB</pre></li></ul></li></ul></li><li><p>例子</p></li></ol><pre class="mermaid">classDiagramclass Parent {  <<Abstract>>    +String name    -int age    #List<String> children    ~Float weight    +eat()    +sleep()}class Child {    +String toy    -Integer grade}Parent "1" <|-- "*" Child : 继承</pre>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树与双向链表</title>
      <link href="/2022/06/07/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/06/07/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><span id="more"></span><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="/2022/06/07/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/bstdllreturndll.png" alt="bstdllreturndll"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="/2022/06/07/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/bstdlloriginalbst.png" alt="bstdlloriginalbst"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><p>思路: 可以将整颗树的转化分解为左子树转化和右子树转化. 然后对于左子树转化后的结果获取头尾节点更新与当前根节点的指针即可, 右子树同样如此</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123; </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 返回节点,默认当前根节点</span></span><br><span class="line">         <span class="type">Node</span> <span class="variable">ret</span> <span class="operator">=</span> root;</span><br><span class="line">         <span class="comment">// 尾结点,默认根节点</span></span><br><span class="line">         <span class="type">Node</span> <span class="variable">end</span> <span class="operator">=</span> root;</span><br><span class="line">         <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">         <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">         <span class="comment">// 左侧双向链表</span></span><br><span class="line">         <span class="type">Node</span> <span class="variable">linkLeft</span> <span class="operator">=</span> treeToDoublyList(left);</span><br><span class="line">         <span class="comment">// 右侧双向链表</span></span><br><span class="line">         <span class="type">Node</span> <span class="variable">linkRight</span> <span class="operator">=</span> treeToDoublyList(right);</span><br><span class="line">         <span class="keyword">if</span>(linkLeft != <span class="literal">null</span>) &#123;</span><br><span class="line">             ret = linkLeft;</span><br><span class="line">             <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> linkLeft;</span><br><span class="line">             <span class="comment">// 这里是寻找子树尾结点(后续可以优化)</span></span><br><span class="line">             <span class="keyword">while</span>(tmp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span>(tmp.right == linkLeft)&#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 tmp = tmp.right;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 更新指针指向</span></span><br><span class="line">             tmp.right = root;</span><br><span class="line">             root.left = tmp;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(linkRight != <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> linkRight;</span><br><span class="line">             <span class="keyword">while</span>(tmp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span>(tmp.right == linkRight)&#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 tmp = tmp.right;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 更新指针指向</span></span><br><span class="line">             root.right = linkRight;</span><br><span class="line">             linkRight.left = root;</span><br><span class="line">             <span class="comment">// 更新头尾节点的指向关系</span></span><br><span class="line">             tmp.right = ret;</span><br><span class="line">             ret.left = tmp;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ret.left = root;</span><br><span class="line">             root.right = ret;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长度最小的子数组</title>
      <link href="/2022/06/07/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/06/07/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p>思路: 先遍历找到第一个累加到大于等于target的索引值idx,找不到就返回0. 随后设置左指针为0, 右指针为idx. 通过控制左右指针移动寻找最短连续子数组长度</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 最短长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">match</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 当前累计和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从0开始第一个累计和达到target的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">beginIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">                beginIdx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(beginIdx == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> beginIdx;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r &amp;&amp; r &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">                match = Math.min(match, r - l + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(match == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前sum满足条件,尝试左指针右移并更新sum</span></span><br><span class="line">                sum -= nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前sum不满足条件,右指针右移并更新sum</span></span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= nums.length)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复制带随机指针的链表</title>
      <link href="/2022/06/07/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/06/07/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">复制带随机指针的链表</a></h4><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><span id="more"></span><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p>思路：首先遍历原链表，并在遍历过程中创建复制节点，并且维护一个新旧节点的映射关系。然后第二次遍历时，根据映射关系，找出每一个random节点在新链表的节点并指向它。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Node, Node&gt; nmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">bak</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodebak</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">ret</span> <span class="operator">=</span> node;</span><br><span class="line">        nmap.put(head, node);</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            nmap.put(head, next);</span><br><span class="line">            node.next = next;</span><br><span class="line">            node = node.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(bak!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">radom</span> <span class="operator">=</span> bak.random;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rnode</span> <span class="operator">=</span> nmap.get(radom);</span><br><span class="line">            nodebak.random = rnode;</span><br><span class="line">            nodebak = nodebak.next;</span><br><span class="line">            bak = bak.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打家劫舍</title>
      <link href="/2022/06/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
      <url>/2022/06/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p>思路1: 递归实现,以任一个房屋开始,对于下一个不触发警报的房屋进行决策:是否偷他?! 然后对于不同的状况继续进行偷取. 在每一次偷取成功后就尝试更新最大偷盗金额.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        rob(nums, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * home 当前偷到哪一个房子了</span></span><br><span class="line"><span class="comment">     * money 当前偷了多少钱了</span></span><br><span class="line"><span class="comment">     * last 最后一个偷的房间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> home, <span class="type">int</span> money, Integer last)</span> &#123;</span><br><span class="line">        max = Math.max(max, money);</span><br><span class="line">        <span class="keyword">if</span>(home &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> home; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(last == <span class="literal">null</span>) &#123;</span><br><span class="line">                rob(nums, i, nums[i] + money, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 确认不会触发报警</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; last + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 偷,然后继续下一个房间</span></span><br><span class="line">                    rob(nums, i, nums[i] + money, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(last == <span class="literal">null</span>) &#123;</span><br><span class="line">                rob(nums, i+<span class="number">1</span>, money, i+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; last + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不偷,继续下一个房间</span></span><br><span class="line">                    rob(nums, i + <span class="number">1</span>, money, i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2: 动态规划, 定义dp数组, dp[i] 代表到第i位最大的金额,存在状态转移关系:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = nums[i] i == 0</span><br><span class="line">dp[i] = max(nums[i], dp[i-1], dp[i-1]) i &gt; 0, i &gt; 1</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> i - <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">last2</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(last2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[last] + nums[i], dp[i]);</span><br><span class="line">                &#125; </span><br><span class="line">                dp[i] = Math.max(dp[i], nums[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> dp </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本计算器II</title>
      <link href="/2022/06/05/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/"/>
      <url>/2022/06/05/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/basic-calculator-ii/">基本计算器 II</a></p><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。</p><p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><p>思路: 维护一个操作符栈和操作数栈以及操作符优先级字典. 流程如下: 遇到数字入栈,遇到操作符,如果优先级小于已入栈的操作符, 计算之前大于该操作符的操作,并将计算结果入栈操作数栈. 然后入栈新操作符,重复以上操作. 最终返回操作符栈剩下的结果即可.</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        Stack&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Map&lt;Character, Integer&gt; pmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        pmap.put(<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        pmap.put(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        pmap.put(<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        pmap.put(<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!sb.isEmpty()) &#123;</span><br><span class="line">                    nums.push(Integer.parseInt(sb.toString()));</span><br><span class="line">                    sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pmap.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!sb.isEmpty()) &#123;</span><br><span class="line">                    nums.push(Integer.parseInt(sb.toString()));</span><br><span class="line">                    sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ops.isEmpty()) &#123;</span><br><span class="line">                    ops.push(c);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!ops.isEmpty() &amp;&amp; pmap.get(ops.peek()) &gt;= pmap.get(c)) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> nums.pop();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> nums.pop();</span><br><span class="line">                        nums.push(calc(v1, v2, ops.pop()));   </span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!sb.isEmpty()) &#123;</span><br><span class="line">            nums.push(Integer.parseInt(sb.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!ops.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> nums.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> nums.pop();</span><br><span class="line">            nums.push(calc(v1, v2, ops.pop()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">char</span> op)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> v1 + v2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> v1 - v2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> v1 * v2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> v1 / v2;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数据结构</title>
      <link href="/2022/06/05/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/06/05/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>数组, 链表</p><p>栈, 堆, 树, 图</p><span id="more"></span><ol><li><p>数组</p></li><li><p>链表</p><p>优点:</p><p>缺点: 节点内存不连续, 无法很好的利用CPU缓存. 同时链表需要维护指针带来的内存开销</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英文面试自我介绍</title>
      <link href="/2022/06/05/%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/06/05/%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>转自: <a href="https://zhuanlan.zhihu.com/p/30566237">英文面试准备</a></p><p>外企面试，英文自我介绍是必答题，是送分题。</p><p>无论是电话面试，还是face to face面试，只要能流利，语速适度的完成1分钟左右自我介绍，基本都可以通关。</p><p>而大部分面试者，要么没有准备，要么磕磕巴巴，要么自我介绍太长，要么语速过快……</p><p>如果你面试环节的自我介绍被面试官打断了，99%是个失败的自我介绍。 </p><span id="more"></span><h2 id="01-自我介绍方程式"><a href="#01-自我介绍方程式" class="headerlink" title="01 自我介绍方程式"></a><strong>01 自我介绍方程式</strong></h2><h2 id="A-For-New-Graduates-毕业生自我介绍"><a href="#A-For-New-Graduates-毕业生自我介绍" class="headerlink" title="A. For New Graduates 毕业生自我介绍"></a><strong>A. For New Graduates 毕业生自我介绍</strong></h2><p>我叫小小，xx大学，xx专业毕业。大学期间我顺利通过xx级，xx级，拿到xx证书，我的平均成绩都在Top xx，我是xx协会的xx，是xx志愿者，我在平时还参加了xx实践项目。我熟练掌握英语、计算机和xx，精通office软件，具有(可以开始说你的各种能力)良好的沟通能力，xx能力，xx能力，xx能力，和人际交往能力….我相信我很适合xx职位.谢谢。</p><p>I am <strong>Xiao Xiao</strong>. I recently graduated from <strong>×× University</strong> with a <strong>bachelor degree in Business Accounting</strong>. My GPA was among the <strong>top 3</strong> in my class. I passed <strong>CET6.</strong> Besides studying I was very active on campus. I participated in <strong>volunteer activities</strong> whenever I had time. I became the <strong>Chairman for the Student Union</strong> during my senior year. I also worked with Baidu as a <strong>Social Media Intern</strong> for a semester. I learned a lot about <strong>content curation</strong> and <strong>using social media tools</strong>. I could speak <strong>（pretty） good English</strong> and I’m fluent in Mandarin Chinese (Hahaha…因为我是中国人). I am highly proficient with <strong>Office.</strong> I have great communication <strong>skills</strong>. I am an <strong>outgoing person</strong>. I am very <strong>responsible and hardworking</strong>. I believe I’m a good fit for the Department Assistant position. Thank you for the opportunity.</p><p>描述顺序拆解：</p><p><img src="/2022/06/05/%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/v2-e8f4b001bc4db1ad2b8f28bd3ec8f525_r.jpg" alt="v2-e8f4b001bc4db1ad2b8f28bd3ec8f525_r"></p><p><strong>B. For Working Professionals 有工作经验自我介绍</strong></p><p>我是小小，具有xx年xx领域的经验，现在是xx公司xx职位。之前是有xx年xx行业经验，xx行业xx经验。我的专长是xx比如说品牌管理和业务发展。我也很擅长xx比如说项目管理和活动策划。我英语很好英语、计算机和xx，擅长xx， 在工作中，我曾经获得xx等奖项。我有优秀的沟通技能，有很强的团队精神和自我驱动力。我相信以我的经验和热情我能够在xx岗位上给xx公司的成功做出贡献。谢谢。</p><p>I am <strong>Xiao Xiao</strong>. I have <strong>over 8 years of experience in marketing</strong>. I am the <strong>team manager of marketing for HP since 2013</strong>. Previously I worked in <strong>IT for a year</strong> and <strong>retail for another 4 years or so</strong>. My specialties include <strong>brand management</strong> and <strong>business development</strong>. I’m also very experienced with <strong>project management</strong> and <strong>event coordination</strong>. I was voted the <strong>2016 Best Employee</strong> among my peers. I could speak <strong>（pretty） good English</strong> and I’m fluent in Mandarin Chinese(Hahaha…因为我是中国人). I am highly proficient with <strong>Microsoft Office softwares and Photoshop</strong>. I have <strong>excellent written and verbal communication skills</strong>. I’m a <strong>team player and self-driven</strong>. I believe I have the combination of experience and enthusiasm to contribute to the success of Intel Shanghai as the Senior Manager of Marketing. Thanks. </p><p>描述顺序拆解：</p><p><img src="/2022/06/05/%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/v2-be67c5fbf089d4a1fe958c16c9bd82bf_1440w.jpg.png" alt="v2-be67c5fbf089d4a1fe958c16c9bd82bf_1440w.jpg"></p><p><strong>C. Top 10个常用句型</strong></p><p><strong>计算机和英语证书</strong></p><p>I am highly proficient with…</p><p><strong>学习成绩优秀</strong></p><p>My grades were top in the class.</p><p><strong>社团&#x2F;志愿者&#x2F;实践项目</strong></p><p>I was very active on campus.</p><p>I’ve participated in many campus groups, volunteer programs, and practical activities</p><p><strong>具备能力</strong></p><p>I’m passionate about…</p><p>I’m very familiar with…</p><p>I’m experienced with…</p><p><strong>行业经验</strong></p><p>I’ve work in marketing&#x2F;sales&#x2F;business development&#x2F;international education for X years</p><p><strong>管理经验</strong></p><p>I have x years of management experiences</p><p><strong>项目经验</strong></p><p>I took the lead in xxx project which was very successful.</p><p><strong>获奖经历</strong></p><p>I was recognized as…</p><p>I was awarded the…</p><p>I was voted the…</p><p><strong>性格特质</strong></p><p>I’m a people person.</p><p>I’m a team player.</p><p>I’m very hardworking.</p><p>I’m super self-driven.</p><p><strong>职位匹配描述</strong></p><p>I believe I have the right combination of experience and enthusiasm to be successful in xxx position.</p><p>I believe I am a good fit for xxx company as the xxx position. </p><p>I believe I can do a great job as your xxx.</p><p><strong>D: General Skill list 通用技能列表</strong></p><p><strong>Personality and Characteristics 好用的性格和特征</strong></p><p>A people person; 善于与人打交道的人</p><p>A team player; 善于团队合作的人</p><p>A good listener;好的倾听者</p><p>A good leader; 好的领导</p><p>An analytical thinker; 善于分析的思考者</p><p>Hard working; 勤奋的</p><p>Self-motivated;有上进心的，积极主动的</p><p>Very driven;自我驱动很强的</p><p>Adaptable; 适应能力不错</p><p>Energetic;精力充沛的</p><p>Proactive;积极主动的</p><p>Business oriented;商业&#x2F;业务导向的</p><p>Results oriented;结果导向的</p><p>High attention to detail; 非常关注细节</p><p><strong>Skills 技能</strong></p><p>Excellent communication skills; 卓越的沟通技能</p><p>Outstanding organization skills; 出众的组织技能</p><p>Great verbal and written communication<br>skills in English and Chinese; 优秀的中英文口语和书面交流技能</p><p>Good interpersonal skills; 很好的交际能力</p><p>Fantastic organizational skills; 极好组织能力</p><p>Excellent time management skills;卓越的时间管理技能</p><p>Fantastic negotiation skills；极好的谈判技能</p><p>Strong analytical skills; 很强的分析能力</p><p>Highly proficient in PC skills.精通电脑</p><p><strong>Abilities 能力</strong></p><p>Ability to work effectively with staff at all levels; 能和各个级别员工高效工作</p><p>Ability to interpret financial statements&#x2F;statistics; 解释财务报表&#x2F;统计数据的能力</p><p>Strong problem solving ability; 较强的问题处理能力</p><p>Strong business acumen; 良好的商业敏感度</p><p>Ability to prioritize and work within tight timeframe; 能在时间紧迫的情况下安排工作优先等级</p><p>Excellent research ability; 优秀的研究&#x2F;调研能力</p><p>Very familiar with labor law and related policies in China; 非常熟悉劳动法和中国的相关政策法规</p><p>Fluent in both English and Mandarin Chinese;英语和中文都很流利</p><p>Tech savvy；科技通</p><p>Ability to adapt quickly to any new accounting&#x2F;information system; 能够迅速适应任何新会计&#x2F;信息系统</p><p><strong>Computer skills 电脑技能</strong></p><p>Good at Office 精通 Office</p><p>Proficient in Photoshop 精通PS</p><p>High proficiency in PowerPoint 精通PPT</p><p>Advanced level proficiency in Excel 精通Excel</p><p><strong>Certificate List 证书列表</strong></p><p>CET-4;四级</p><p>CET-6;六级</p><p>Certificate of English Interpreting:<br>Preliminary; 英语初级口译</p><p>Certificate of English Interpreting:<br>Intermediate; 英语中级口译</p><p>Certificate of English Interpreting:<br>Advanced; 英语高级口译</p><p>Certificate of Teachers’Qualification (English); 教师资格证书</p><p>Certificate of Mandarin Test.普通话测试证书</p><p>……</p><p><strong>Personality and characteristics 更多性格特质形容词</strong></p><p>aggressive有进取心的,攻击性的 (这不是一个好的特质，听起来像是很有野心)</p><p>passionate&#x2F;enthusiastic 热情的</p><p>creative 富有创造性（力）的</p><p>insightful 富有洞察力的</p><p>diligent 好学的,勤奋的</p><p>liberal 慷慨的,不拘泥的,宽大的</p><p>nice 友善的</p><p>Kind 善良的</p><p>friendly 友善的</p><p>considerate考虑周到的,体谅的</p><p>humorous 幽默的</p><p>confident 自信的</p><p>imaginative 富想像力的</p><p>responsible 负责的</p><p>courageous 勇敢的</p><p>independent 独立的</p><p>demanding 要求多的 （a demanding position对员工要求很多，很高的职位）</p><p>individualistic 个人主义的</p><p>efficient 效率高的,有能力的</p><p>energetic 精力旺盛的</p><p>loyal 忠诚的</p><p>modest 谦虚的</p><p>thoughtful 考虑周到的</p><p>motivated 有动力的</p><p>positive&#x2F;optimistic 积极的&#x2F;乐观的</p><p>open-minded 思想开明的</p><p>trustworthy 值得信赖的</p><p>gentle 温文尔雅的</p><p>precise 精确的</p><p>good-natured 脾气好的,温厚的</p><p>idealistic 理想主义的</p><p>witty 急智的</p><p>wise 明智的,聪明的</p><p>smart&#x2F;intelligent&#x2F;clever 聪明的</p><p>outgoing&#x2F;sociable 爱好交际的</p><p>easy-going 随和的,跟谁都处得来</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构底层原</title>
      <link href="/2022/06/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F/"/>
      <url>/2022/06/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<p>参考: <a href="https://www.cnblogs.com/xiaolincoding/p/15628854.html">Redis数据结构</a></p><p><img src="/2022/06/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lastnew.png" alt="redis数据结构-lastnew"></p><p><img src="/2022/06/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F/redis%E5%85%A8%E6%99%AF%E5%9B%BE.png" alt="redis全景图"></p><p>*redis存储访问流程</p><ul><li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li><li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用；</li><li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li><li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 <strong>void * key 和 void * value 指针， *key 指向的是 String 对象，而 *value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象</strong>。</li></ul><span id="more"></span><h1 id="string：字符串"><a href="#string：字符串" class="headerlink" title="string：字符串"></a>string：字符串</h1><p>redis使用c语言开发, 在redis中，其自己定义了一种字符串格式，叫做SDS（Simple Dynamic String），即简单动态字符串. 结构定义sds.h:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br></pre></td></tr></table></figure><p>sds包含以下属性:</p><ul><li>len：已使用的长度，即字符串的真实长度. 降低获取字符串长度复杂度到O(1). 同时帮助二进制安全</li><li>alloc：分配的长度, 除去标头和终止符(‘\0’)后的长度. 减少而内存分配次数</li><li>flags：表示不同类型的SDS, 低3位表示</li><li>buf[]：存储字符数据</li></ul><h1 id="list：列表"><a href="#list：列表" class="headerlink" title="list：列表"></a>list：列表</h1><p>使用双向链表, 获取节点前后节点时间复杂度O(1),获取头尾节点也是O(1). 同时链表使用指针保存值, 可以保存各种类型的数据.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>ziplist</p><p><img src="/2022/06/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84.png" alt="压缩列表节点结构"></p><p>相比链表, 设计为更为内存紧凑的数据结构, 可以有效利用CPU缓存. 而且针对不同长度数据进行编码以节省内存开销. 同样存在缺陷: 不可以保存过多的元素,新增修改元素时,内存需要重分配和引发连锁更新问题.</p><ul><li>zlbytes：4个字节（32bits），表示ziplist占用的总字节数</li><li>zltail：4个字节（32bits），表示ziplist中最后一个节点在ziplist中的偏移字节数</li><li>entries：2个字节（16bits），表示ziplist中的元素数</li><li>entry：长度不定，表示ziplist中的数据 (内部包含prevlen: 记录前一个节点长度(如果内存重新分配,后续的该字段都要更新,造成性能下降–<strong>连锁更新问题</strong>), encoding: 记录当前节点类型与长度, data: 数据)</li><li>zlend：1个字节（8bits），表示结束标记，这个值固定为ff（255）</li></ul><p>这些数据均为小端存储，所以可能有些人查看数据的二进制流与其含义对应不上，其实是因为读数据的方式错了</p><p>ziplist内部采取数据压缩的方式进行存储，压缩方式就不是重点了，我们仅从宏观来看，ziplist类似一个封装的数组，通过zltail可以方便地进行追加和删除尾部数据、使用entries可以方便地计算长度</p><p>但是其依然有数组的缺点，就是当插入和删除数据时会频繁地引起数据移动，所以就引出了quicklist数据类型</p></li><li><p>quick list</p><p>「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p><p><img src="/2022/06/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F/quicklist.png" alt="quicklist"></p></li><li><p>listpack</p><p><img src="/2022/06/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F/listpack%E8%8A%82%E7%82%B9.png" alt="listpack节点"></p></li></ul><h1 id="hash：散列表"><a href="#hash：散列表" class="headerlink" title="hash：散列表"></a>hash：散列表</h1><p><img src="/2022/06/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%8E%9F/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="哈希表结构"></p><ul><li>哈希冲突</li><li>链式哈希</li><li>rehash</li><li>渐进式 rehash</li><li>rehash 触发条件</li></ul><h1 id="set：无序集合"><a href="#set：无序集合" class="headerlink" title="set：无序集合"></a>set：无序集合</h1><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不时，就会使用整数集这个数据结构作为底层实现。</p><ul><li>整数集合</li></ul><h1 id="zset：有序集合"><a href="#zset：有序集合" class="headerlink" title="zset：有序集合"></a>zset：有序集合</h1><p>内部使用跳表</p><ul><li>跳表</li></ul><p>待补充</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP半连接队列和全连接队列溢出</title>
      <link href="/2022/06/04/TCP%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA/"/>
      <url>/2022/06/04/TCP%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>转自: <a href="https://www.cnblogs.com/sidesky/p/6844228.html">TCP连接队列</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA的client和server，使用socket通信。server使用NIO。</span><br><span class="line">1.间歇性的出现client向server建立连接三次握手已经完成，但server的selector没有响应到这连接。</span><br><span class="line">2.出问题的时间点，会同时有很多连接出现这个问题。</span><br><span class="line">3.selector没有销毁重建，一直用的都是一个。</span><br><span class="line">4.程序刚启动的时候必会出现一些，之后会间歇性出现。</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><ul><li>第一步：client 发送 syn 到server 发起握手；</li><li>第二步：server 收到 syn后回复syn+ack给client；</li><li>第三步：client 收到syn+ack后，回复server一个ack表示收到了server的syn+ack（此时client的56911端口的连接已经是established）</li></ul><p>从问题的描述来看，有点像TCP建连接的时候全连接队列（accept队列）满了，尤其是症状2、4. 为了证明是这个原因，马上通过 ss -s 去看队列的溢出统计数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">667399 times the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure><p>反复看了几次之后发现这个overflowed 一直在增加，那么可以明确的是server上全连接队列一定溢出了</p><p>接着查看溢出后，OS怎么处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/net/ipv4/tcp_abort_on_overflow</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>tcp_abort_on_overflow 为0表示如果三次握手第三步的时候全连接队列满了那么server扔掉client 发过来的ack（在server端认为连接还没建立起来）</p><p>为了证明客户端应用代码的异常跟全连接队列满有关系，我先把tcp_abort_on_overflow修改成 1，1表示第三步的时候如果全连接队列满了，server发送一个reset包给client，表示废掉这个握手过程和这个连接（本来在server端这个连接就还没建立起来）。</p><p>接着测试然后在客户端异常中可以看到很多connection reset by peer的错误，到此证明客户端错误是这个原因导致的。</p><p>于是开发同学翻看java 源代码发现socket 默认的backlog（这个值控制全连接队列的大小，后面再详述）是50，于是改大重新跑，经过12个小时以上的压测，这个错误一次都没出现过，同时 overflowed 也不再增加了。</p><p>到此问题解决，简单来说TCP三次握手后有个accept队列，进到这个队列才能从Listen变成accept，默认backlog 值是50，很容易就满了。满了之后握手第三步的时候server就忽略了client发过来的ack包（隔一段时间server重发握手第二步的syn+ack包给client），如果这个连接一直排不上队就异常了。</p><h1 id="TCP握手创建流程"><a href="#TCP握手创建流程" class="headerlink" title="TCP握手创建流程"></a>TCP握手创建流程</h1><p><img src="/2022/06/04/TCP%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA/3d05f574867b70d1134e685e5f5ac137.jpg" alt="3d05f574867b70d1134e685e5f5ac137"></p><p>在 TCP 三次握手的过程中，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列 (SYN Queue)</li><li>全连接队列 (Accept Queue)</li></ul><p>正常的 TCP 三次握手过程：</p><ol><li>Client 端向 Server 端发送 SYN 发起握手，Client 端进入 SYN_SENT 状态</li><li>Server 端收到 Client 端的 SYN 请求后，Server 端进入 SYN_RECV 状态，此时内核会将连接存储到半连接队列(SYN Queue)，并向 Client 端回复 SYN+ACK</li><li>Client 端收到 Server 端的 SYN+ACK 后，Client 端回复 ACK 并进入 ESTABLISHED 状态</li><li>Server 端收到 Client 端的 ACK 后，内核将连接从半连接队列(SYN Queue)中取出，添加到全连接队列(Accept Queue)，Server 端进入 ESTABLISHED 状态</li><li>Server 端应用进程调用 accept 函数时，将连接从全连接队列(Accept Queue)中取出</li></ol><p>半连接队列和全连接队列都有长度大小限制，超过限制时内核会将连接 Drop 丢弃或者返回 RST 包。</p><h1 id="相关指标查看"><a href="#相关指标查看" class="headerlink" title="相关指标查看"></a>相关指标查看</h1><ul><li><p>ss 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># -n 不解析服务名称 </span><br><span class="line"># -t 只显示 tcp sockets </span><br><span class="line"># -l 显示正在监听(LISTEN)的 sockets </span><br><span class="line"> </span><br><span class="line">$ ss -lnt </span><br><span class="line">State      Recv-Q Send-Q    Local Address:Port         Peer Address:Port </span><br><span class="line">LISTEN     0      128       [::]:2380                  [::]:* </span><br><span class="line">LISTEN     0      128       [::]:80                    [::]:* </span><br><span class="line">LISTEN     0      128       [::]:8080                  [::]:* </span><br><span class="line">LISTEN     0      128       [::]:8090                  [::]:* </span><br><span class="line"> </span><br><span class="line">$ ss -nt </span><br><span class="line">State      Recv-Q Send-Q    Local Address:Port         Peer Address:Port </span><br><span class="line">ESTAB      0      0         [::ffff:33.9.95.134]:80                   [::ffff:33.51.103.59]:47452 </span><br><span class="line">ESTAB      0      536       [::ffff:33.9.95.134]:80                  [::ffff:33.43.108.144]:37656 </span><br><span class="line">ESTAB      0      0         [::ffff:33.9.95.134]:80                   [::ffff:33.51.103.59]:38130 </span><br><span class="line">ESTAB      0      536       [::ffff:33.9.95.134]:80                   [::ffff:33.51.103.59]:38280 </span><br><span class="line">ESTAB      0      0         [::ffff:33.9.95.134]:80                   [:: </span><br></pre></td></tr></table></figure><p>LISTEN状态Socket</p><ul><li>Recv-Q：当前全连接队列的大小，即已完成三次握手等待应用程序 accept() 的 TCP 链接</li><li>Send-Q：全连接队列的最大长度，即全连接队列的大小</li></ul><p>非LISTEN状态Socket</p><ul><li>Recv-Q：已收到但未被应用程序读取的字节数</li><li>Send-Q：已发送但未收到确认的字节数</li></ul></li><li><p>netstat命令</p><p>通过 netstat -s 命令可以查看 TCP 半连接队列、全连接队列的溢出情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -s | grep -i &quot;listen&quot; </span><br><span class="line">189088 times the listen queue of a socket overflowed </span><br><span class="line">30140232 SYNs to LISTEN sockets dropped </span><br></pre></td></tr></table></figure><p>上面输出的数值是累计值，分别表示有多少 TCP socket 链接因为全连接队列、半连接队列满了而被丢弃</p><ul><li>189088 times the listen queue of a socket overflowed 代表有 189088 次全连接队列溢出</li><li>30140232 SYNs to LISTEN sockets dropped 代表有 30140232 次半连接队列溢出</li></ul><p>在排查线上问题时，如果一段时间内相关数值一直在上升，则表明半连接队列、全连接队列有溢出情况</p></li></ul><p>其他内容待补充, 参考文首链接</p>]]></content>
      
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构化,半结构化和非结构化数据</title>
      <link href="/2022/06/04/%E7%BB%93%E6%9E%84%E5%8C%96-%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E5%92%8C%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/06/04/%E7%BB%93%E6%9E%84%E5%8C%96-%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E5%92%8C%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="https://cloud.tencent.com/developer/article/1351609">https://cloud.tencent.com/developer/article/1351609</a></p><h1 id="一、结构化数据"><a href="#一、结构化数据" class="headerlink" title="一、结构化数据"></a><strong>一、结构化数据</strong></h1><p>结构化的数据是指可以使用<a href="https://cloud.tencent.com/product/cdb-overview?from=10680">关系型数据库</a>表示和存储，表现为二维形式的数据。一般特点是：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。举一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id      name            age     gender</span><br><span class="line"><span class="number">1</span>       <span class="title class_">Liu</span> <span class="title class_">Yi</span>          <span class="number">20</span>      male</span><br><span class="line"><span class="number">2</span>       <span class="title class_">Chen</span> <span class="title class_">Er</span>         <span class="number">35</span>      female</span><br><span class="line"><span class="number">3</span>       <span class="title class_">Zhang</span> <span class="title class_">San</span>       <span class="number">28</span>      male</span><br></pre></td></tr></table></figure><span id="more"></span><p>所以，结构化的数据的存储和排列是很有规律的，这对查询和修改等操作很有帮助。</p><p>但是，它的扩展性不好。比如，如果字段不固定，利用关系型数据库也是比较困难的，有人会说，需要的时候加个字段就可以了，这样的方法也不是不可以，但在实际运用中每次都进行反复的表结构变更是非常痛苦的，这也容易导致后台接口从数据库取数据出错。你也可以预先设定大量的预备字段，但这样的话，时间一长很容易弄不清除字段和数据的对应状态，即哪个字段保存有哪些数据。</p><h1 id="二、半结构化数据"><a href="#二、半结构化数据" class="headerlink" title="二、半结构化数据"></a><strong>二、半结构化数据</strong></h1><p>半结构化数据是结构化数据的一种形式，它并不符合关系型数据库或其他数据表的形式关联起来的数据模型结构，但包含相关标记，用来分隔语义元素以及对记录和字段进行分层。因此，它也被称为自描述的结构。</p><p>半结构化数据，属于同一类实体可以有不同的属性，即使他们被组合在一起，这些属性的顺序并不重要。</p><p>常见的半结构数据有XML和JSON，对于对于两个XML文件，第一个可能有</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span>A<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">age</span>&gt;</span>13<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span></span><br><span class="line">&lt;/person&gt;</span><br></pre></td></tr></table></figure><p>复制</p><p>第二个可能为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span>B<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span></span><br><span class="line">&lt;/person&gt;</span><br></pre></td></tr></table></figure><p>复制</p><p>从上面的例子中，属性的顺序是不重要的，不同的半结构化数据的属性的个数是不一定一样的。有些人说半结构化数据是以树或者图的数据结构存储的数据，怎么理解呢？上面的例子中，标签是树的根节点，和标签是子节点。通过这样的数据格式，可以自由地表达很多有用的信息，包括自我描述信息（元数据）。所以，半结构化数据的扩展性是很好的。</p><h1 id="三、非结构化数据"><a href="#三、非结构化数据" class="headerlink" title="三、非结构化数据"></a><strong>三、非结构化数据</strong></h1><p>非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，不方便用数据库二维逻辑表来表现的数据。包括所有格式的办公文档、文本、图片、各类报表、图像和音频&#x2F;视频信息等等。</p><p>非结构化数据其格式非常多样，标准也是多样性的，而且在技术上非结构化信息比结构化信息更难标准化和理解。所以存储、检索、发布以及利用需要更加智能化的IT技术，比如海量存储、智能检索、知识挖掘、内容保护、信息的增值开发利用等。</p><h1 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a><strong>四、应用场景</strong></h1><p>结构化数据，简单来说就是数据库。结合到典型场景中更容易理解，比如企业ERP、财务系统；医疗HIS数据库；教育一卡通；政府行政审批；其他核心数据库等。这些应用需要哪些存储方案呢？基本包括高速存储应用需求、数据备份需求、数据共享需求以及数据容灾需求。</p><p>非结构化数据，包括视频、音频、图片、图像、文档、文本等形式。具体到典型案例中，像是医疗影像系统、教育视频点播、视频监控、国土GIS、设计院、文件服务器（PDM&#x2F;FTP）、媒体资源管理等具体应用，这些行业对于存储需求包括数据存储、数据备份以及数据共享等。</p><p>半结构化数据，包括邮件、HTML、报表、资源库等等，典型场景如邮件系统、WEB集群、教学资源库、数据挖掘系统、档案系统等等。这些应用对于数据存储、数据备份、数据共享以及数据归档 等基本存储需求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL命令explain</title>
      <link href="/2022/06/04/MySQL%E5%91%BD%E4%BB%A4explain/"/>
      <url>/2022/06/04/MySQL%E5%91%BD%E4%BB%A4explain/</url>
      
        <content type="html"><![CDATA[<p><code>explain</code>是MySQL查询优化的关键命令. 通过这个命令可以模拟优化器执行SQL查询语句, 分析执行结果可以优化查询语句以提升查询性能.</p><span id="more"></span><p>语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xx <span class="keyword">where</span> yy <span class="operator">=</span> <span class="string">&#x27;zz&#x27;</span></span><br></pre></td></tr></table></figure><p>相应字段介绍:</p><ul><li><p>id : 语句中select查询子句的顺序</p></li><li><p>select_type : 查询类型</p><ul><li><p>SIMPLE : 简单查询, 不包含子查询与union查询</p></li><li><p>PRIMARY : 主查询, 存在子查询时,外层查询被标记为主查询</p></li><li><p>SUBQUERY : 子查询</p></li><li><p>UNION : 在union命令后的语句为此类型</p></li><li><p>UNION RESULT : 最终UNION结果会表示为此类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type   table       partitions  type    possible_keys        key      </span><br><span class="line">------  ------------  ----------  ----------  ------  -------------------  ------- </span><br><span class="line">     1  PRIMARY       student     (NULL)      const   PRIMARY,id_name_age  PRIMARY  </span><br><span class="line">     2  UNION         student     (NULL)      const   PRIMARY,id_name_age  PRIMARY </span><br><span class="line">(NULL)  UNION RESULT  &lt;union1,2&gt;  (NULL)      ALL     (NULL)               (NULL)   </span><br></pre></td></tr></table></figure></li><li><p>DERIVED : FROM列表中包含子查询的语句被标记为此类型, MySQL会递归执行这些子查询放入临时表(MySQL 5.7+ 优化后使用derived_merge加速查询效率. 无此状态)</p></li></ul></li><li><p>table : 访问的表,结合id可以看到执行过程中表查询顺序</p></li><li><p>partitions : 匹配分区</p></li><li><p>type : 访问类型</p><p>10个状态,从好到差排序:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure><ul><li><p>NULL : 无需访问表和索引的查询. 例: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">5</span><span class="operator">*</span><span class="number">7</span>  <span class="comment">-- 不访问表,计算数值</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(id) <span class="keyword">FROM</span> student  <span class="comment">-- 查询最大索引,直接取索引树叶子结点获取 </span></span><br></pre></td></tr></table></figure></li><li><p>SYSTEM : 表只有一行记录（等于系统表），这是<code>const</code>类型的特列，平时不大会出现，可以忽略。</p></li><li><p>const : 一次索引查找到,主键索引或唯一索引查询时</p></li><li><p>eq_ref : 联表join查询时, 按联表的主键或唯一键查询</p></li><li><p>ref : 联表join查询时, 按联表的索引查询, 匹配多行不唯一</p></li><li><p>ref_or_null : 类似ref, 可以搜索值为NULL的行</p></li><li><p>index_merge : 查询了多个索引,然后取交集并集. 常见于在<code>and</code>, ‘or’的条件下使用了不同的索引. 大部分性能不如<code>range</code></p></li><li><p>range : 索引范围查询,常见于 &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, IN()或者like等运算符的查询中</p></li><li><p>ALL : 全表扫描, 务必优化!!!</p></li></ul></li><li><p>possible_keys : 可能使用的索引</p></li><li><p>key : 实际使用的索引, 为null时表示没使用索引</p></li><li><p>key_len : 索引中使用的字节数</p></li><li><p>ref : 索引的哪一列被使用</p></li><li><p>rows : 根据表统计信息以及索引选用情况,估算查找所需记录需要读取的行数. 数值越小效率越高</p></li><li><p>filtere : 查询数据占表的百分比. 类似rows,数值越小效率越高</p></li><li><p>extra : 其他重要的额外信息</p><ul><li>Using filesort : SQL需要排序, 但是优化器找不到可以使用的索引, 此时使用外部排序(多次磁盘IO访问,效率极低)</li><li>Using tempporary : 查询结果排序时, 使用临时表协助. 效率低于外部排序.</li><li>Using index : 使用了索引 👍🏻👍🏻👍🏻</li><li>Using where : 使用了where</li><li>Using join buffer : 多表join使用了连接缓存</li><li>impossible where : 筛选条件啥也没找到</li><li>distinct : 优化distinct操作, 找到匹配后立即停止同样值的动作</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql 面试</title>
      <link href="/2022/06/04/Sql-%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/06/04/Sql-%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p>having</p><p>having常用语分组后的条件过滤常用于<code>group by xx </code>后</p><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">HAVING</span> aggregate_function(column_name) operator <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>注意事项:</p><ul><li>having 子句内容需要存在select列表中</li><li>having限制的是组, where限制的是行</li><li>where, group by, having执行顺序: where过滤行 -&gt; group by对数据分组,并执行聚集函数 -&gt; having过滤符合条件的组</li></ul><span id="more"></span></li><li><p><code>select a.xx,b.xx from a,b where a.x = b.x</code>与<code>select a.xx,b.xx from a inner join b on a.x = b.x</code> 区别</p></li><li><p>union与union all</p><p>union会去重, union all 直接合并</p></li><li><p>row_number()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在test表中根据name分组，age进行排序</span></span><br><span class="line"><span class="keyword">select</span> name,age,<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">age <span class="keyword">desc</span>) <span class="keyword">from</span> test;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--去掉重复的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> name,age,<span class="built_in">row_number</span>() <span class="keyword">over</span>( <span class="keyword">partition</span> <span class="keyword">by</span> name </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>) rn <span class="keyword">from</span> test )<span class="keyword">where</span> rn<span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>可以对结果集进行分组排序并生成一个row_number序列</p></li><li><p>DDL, DML与DCL</p><ul><li>DDL: Data Define Language, 数据定义语句. CREATE, ALTER, DROP等</li><li>DML: Data Manage Language, 数据管理语句. SELECT, UPDATE, INSERT, DELETE</li><li>DCL: Data Control Language, 数据控制语句. GRANT, DENY, REVOKE等个更新用户角色的命令</li></ul></li><li><p>exists 与 in</p><ul><li><code>in</code> 仅执行一次(先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选), <code>exists</code>执行多次(外表行数)</li><li>外层查询小于子查询使用<code>exists</code>; 外层查询大于子查询使用<code>in</code></li><li><code>in</code> 与<code>exists</code>都会使用索引</li><li><code>not in</code> 内外表均全局扫描,无法使用索引, <code>not exists</code>可以走索引</li><li><code>in</code>的遍历实在内存中,速度较快. <code>exists</code>多次查询数据库.</li></ul></li><li><p>索引使用注意事项</p><ul><li>尽量全值匹配</li><li>模糊查询使用最左匹配原则</li><li>全模糊查询使用覆盖索引方式也会走索引</li><li>不在索引列上进行操作</li><li>联合索引需要严格顺序匹配</li><li>尽量使用覆盖索引</li><li>mysql在使用<code>!=</code>与<code>&lt;&gt;</code>时索引失效</li><li>字符串不加单引号导致索引失效</li><li><code>or</code>使得索引失效</li></ul></li><li><p>索引创建</p><ul><li>频繁查询的字段应创建索引</li><li>与其他表关联查询的字段创建索引</li><li>频繁更新的字段不适合作为索引</li></ul></li><li><p>sql书写题目</p><p>参考: <a href="https://blog.csdn.net/jason_wang1989/article/details/115278576">经典题目</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Star 法则</title>
      <link href="/2022/06/04/Star-%E6%B3%95%E5%88%99/"/>
      <url>/2022/06/04/Star-%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>摘自百度百科:</p><p>STAR法则,即为Situation Task Action Result的缩写，具体含义是:</p><ul><li>Situation: 事情是在什么情况下发生</li><li>Task: 任务</li><li>Action: 针对这样的情况分析，你采用了什么行动方式</li><li>Result: 结果怎样，在这样的情况下你学习到了什么</li></ul><span id="more"></span><p>简而言之，STAR法则是一个清晰、条理的模板。合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式概念</title>
      <link href="/2022/06/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/06/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<ul><li><p>事务</p><p>事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即原子性、一致性、隔离性和持久性。</p><span id="more"></span></li><li><p>本地事务</p><p>事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性，高效，可靠，状态可以只在资源管理器中维护，而且应用编程模型简单。但是本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器。</p></li><li><p>分布式事务</p><p>当事务由全局事务管理器进行全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的一致提交回滚。</p></li><li><p>两阶段提交</p><p>参考: <a href="https://www.jianshu.com/p/1aa944f44b7b">Two-phase Commit</a></p></li><li><p>BASE理论</p><p>BA(Basic Available) 基本可用, S(Soft) 柔性状态,允许短时间不同步,E(Eventually) 最终一致性</p></li><li><p>CAP定理</p><p>C(Consistency) 一致性, A(Availability) 可用性, P(Partition tolerance) 分区容错性. 分布式场景下只能同时满足两种. 常用的分布式实现: CP (满足一致性和分区容错性, 会存在短暂不可用状态), AP(满足可用性和分区容错性, 但不是强一致).</p></li></ul><p>参考文章: <a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">分布式事务整理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络原理与资源隔离</title>
      <link href="/2022/06/04/Docker-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/"/>
      <url>/2022/06/04/Docker-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>Docker底层通过<code>namespace</code>和<code>cgroup</code>实现. 通过<code>namespace</code>实现资源隔离. 通过cgroup实现资源限制.</p><span id="more"></span><h1 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h1><ul><li><p>Bridge(桥接)</p><p>容器的默认网络模式，docker在安装时会创建一个名为docker0的Linux bridge，在不指定–network的情况下，创建的容器都会默认挂到docker0上面。bridge模式为容器创建独立的网络栈，保证容器内的进程使用独立的网络环境，使容器之间，容器和docker host之间实现网络隔离。</p></li><li><p>Host</p><p>使用宿主机的网卡进行网络访问, 无需转发,网络性能比较好</p></li><li><p>Container</p><p>A容器使用B容器的共享网络(??)</p></li><li><p>None</p><p>这样创建出来的容器完全没有网络</p></li><li><p>User-defined</p><p>用户自定义模式主要可选的有三种网络驱动：bridge、overlay、macvlan。bridge驱动用于创建类似于前面提到的bridge网络;overlay和macvlan驱动用于创建跨主机的网络、IP等。</p></li></ul><p>linux网络基础参考:<a href="https://www.cnblogs.com/jmilkfan-fanguiju/p/12789756.html">虚拟网络</a></p><h1 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h1><ul><li><p>namespace</p><p>参考namespace: <a href="https://www.cnblogs.com/sparkdev/p/9365405.html">linux namespace</a></p></li><li><p>cgroup</p><p>参考cgroup: <a href="https://tech.meituan.com/2015/03/31/cgroups.html">linux cgroup</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘积最大子数组</title>
      <link href="/2022/06/04/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/06/04/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></p><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 32-位 整数。</p><p>子数组 是数组的连续子序列。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><p>思路:</p><p>维护每一个位置最大最小值( 通过这个可以为后续的提供数据支持)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span>(val == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>] = val;</span><br><span class="line">                dp[<span class="number">1</span>] = val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> dp[<span class="number">0</span>] * val;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> dp[<span class="number">1</span>] * val;</span><br><span class="line">                <span class="keyword">if</span>(v1 &gt; v2) &#123;</span><br><span class="line">                    dp[<span class="number">0</span>] = Math.min(v2, val);</span><br><span class="line">                    dp[<span class="number">1</span>] = Math.max(v1, val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[<span class="number">0</span>] = Math.min(v1, val);</span><br><span class="line">                    dp[<span class="number">1</span>] = Math.max(v2, val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串解码</title>
      <link href="/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
      <url>/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/decode-string/">字符串解码</a></p><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><p>思路:如果遇到数字,直接累计<code>count</code>,遇到字母.结果集直接append, 扫描字符串如果遇到<code>&#39;[&#39;</code>则寻找其对应的结束符号<code>&#39;]&#39;</code>,递归计算范围内的字符串,然后根据count和得到的字符串多次append.</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">return</span> calc(s, <span class="number">0</span> , length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 寻找匹配的结束符号索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findEnd</span><span class="params">(String s, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">calc</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= end)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                count.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> findEnd(str, i);</span><br><span class="line">                <span class="comment">// 递归计算子串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> calc(str,i + <span class="number">1</span>,tmp - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!count.isEmpty())&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(count.toString());</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; num; k++)&#123;</span><br><span class="line">                        ret.append(ss);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                count = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                i = tmp + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>岛屿的最大面积</title>
      <link href="/2022/06/03/%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
      <url>/2022/06/03/%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积</a></p><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p><p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><span id="more"></span><p><img src="/2022/06/03/%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/maxarea1-grid.jpg" alt="maxarea1-grid"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">输出：6</span><br><span class="line">解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</span><br></pre></td></tr></table></figure><p>思路: 遍历二维数组,找到节点为1(即陆地)的位置,然后上下左右递归寻找. 对于寻找到的陆地,标记原数组位置值为2(用2来表示已访问过的位置,防止死循环)</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        height = grid.length;</span><br><span class="line">        width = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">                <span class="comment">// 遍历每一个节点更新最值</span></span><br><span class="line">                max = Math.max(max, visit(grid, i, j, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= height || j&lt;<span class="number">0</span> || j &gt;= width)&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 访问过的节点标记为已访问</span></span><br><span class="line">            grid[i][j] = <span class="number">2</span>;</span><br><span class="line">            curr++;</span><br><span class="line">            <span class="comment">// 上下左右遍历</span></span><br><span class="line">            curr =visit(grid, i+<span class="number">1</span>, j, curr);</span><br><span class="line">            curr = visit(grid, i, j+<span class="number">1</span>, curr);</span><br><span class="line">            curr = visit(grid, i-<span class="number">1</span>, j, curr);</span><br><span class="line">            curr = visit(grid, i, j-<span class="number">1</span>, curr);</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长连续序列</title>
      <link href="/2022/06/03/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
      <url>/2022/06/03/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></p><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p>思路: 可以直接排序,然后每一个节点看是否存在(累加一直到不存在).但题目要求时间复杂度O(n).所以采用hash优化的方式</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 创建set,便于后续判断是否包含</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> num;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// !重要优化点! 如果节点前驱在数组中存在则跳过这次寻找不连续点</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(tmp-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环寻找直到不连续,更新最值</span></span><br><span class="line">            <span class="keyword">while</span>(set.contains(tmp))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同路径</title>
      <link href="/2022/06/03/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/06/03/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><span id="more"></span><p><img src="/2022/06/03/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/robot_maze.png" alt="robot_maze"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p>思路1: 递归,  当前节点到终点的路径数等于往右走和往左右的路径和.</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        find(m, n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= m || y &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == m - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123;</span><br><span class="line">            max++;</span><br><span class="line">        &#125;</span><br><span class="line">        find(m, n, x + <span class="number">1</span>, y);</span><br><span class="line">        find(m, n, x, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2: 思路1在leetcode中超时, 所以采用dp数组维护每个位置的路径数,终点位置只有一种.其余位置<code>dp[i][j] = dp[i+1][j] + dp[i][j+1]</code></p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> n - <span class="number">1</span>; column &gt;= <span class="number">0</span>; column--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(row == m - <span class="number">1</span> &amp;&amp; column == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[row][column] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(row + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                        down = dp[row+<span class="number">1</span>][column];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(column + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                        right = dp[row][column+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[row][column] = down + right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序链表中的重复元素</title>
      <link href="/2022/06/03/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>/2022/06/03/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></p><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><span id="more"></span><p><img src="/2022/06/03/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/list1.jpg" alt="list1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>思路: 采用递归处理, 当前链表去重, 等于以当前节点作为根节点的子链表去重,再与当前节点去重选择最终返回的根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在重复</span></span><br><span class="line">        <span class="keyword">if</span>(head.val == next.val) &#123;</span><br><span class="line">            <span class="comment">// 去重子链表</span></span><br><span class="line">            next.next = deleteDuplicates(next.next);</span><br><span class="line">            <span class="comment">// 如果去重后的子链表头与当前节点存在重复</span></span><br><span class="line">            <span class="keyword">if</span>(next.next != <span class="literal">null</span> &amp;&amp; next.next.val == next.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = deleteDuplicates(next);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2022/06/03/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
      <url>/2022/06/03/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p>思路: 要求O(log n)时间复杂度. 采用二分查找即可. 先通过二分查找寻找target, 如果没有找到则返回<code>[-1, -1]</code>,否则根据找到的索引左右扩展知道不等于target为止. 返回左右拓展的最后位置即可</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 寻找target索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> midSearch(nums, target, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 找不到</span></span><br><span class="line">        <span class="keyword">if</span>(pos == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> pos;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> pos;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftBound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightBound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 左右扩展</span></span><br><span class="line">        <span class="keyword">while</span>(!leftBound || !rightBound) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= <span class="number">0</span> &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftBound = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; nums.length &amp;&amp; nums[right] == target) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightBound = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left+<span class="number">1</span>, right-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">midSearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> midSearch(nums, target, mid+<span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> midSearch(nums, target, start, mid-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长重复子数组</title>
      <link href="/2022/06/03/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/06/03/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> </p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure><p>思路：定义<code>dp[i][j]</code>数组为第一个数组<code>i</code>索引与第二个数组<code>j</code>索引结尾子数组最大公共长度。同时存在状态转移关系：</p><p><code>dp[i][j] = dp[i-1][j-1]+1 when nums1[i] == nums2[j] and i != 0 and j != 0</code></p><p><code>dp[i][j] = 1 when nums1[i] == nums2[j] and i==0 || j == 0</code></p><p><code>dp[i][j] = 0 when nums1[i] != nums2[j] and i==0 || j == 0</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1][l2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; l2; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">csame</span> <span class="operator">=</span> nums1[i] == nums2[j];</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = csame ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(csame) &#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(dp[i][j], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合总和</title>
      <link href="/2022/06/03/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2022/06/03/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combination-sum/">组合总和</a></p><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><span id="more"></span><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span></span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">7</span>]]</span><br><span class="line">解释：</span><br><span class="line"><span class="number">2</span> 和 <span class="number">3</span> 可以形成一组候选，<span class="number">2</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">7</span> 。注意 <span class="number">2</span> 可以使用多次。</span><br><span class="line"><span class="number">7</span> 也是一个候选， <span class="number">7</span> = <span class="number">7</span> 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p>思路：针对候选数组，每次可以有三种操作：</p><ul><li>选取一个继续下一个</li><li>选取后不往下走（可重复选取）</li><li>不选取往下走</li></ul><p>经分析，发现第一个操作的结果会背后两个操作包含，所以只需要考虑后两种即可</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; rsl = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        find(candidates, <span class="number">0</span>, target, path);</span><br><span class="line">        <span class="keyword">return</span> rsl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> idx, <span class="type">int</span> target, List&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            rsl.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx &gt; candidates.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> candidates[idx];</span><br><span class="line">        <span class="comment">// 拿了往下走，被包含所以不用做</span></span><br><span class="line">        <span class="comment">// path.add(cur);</span></span><br><span class="line">        <span class="comment">// find(candidates, idx+1, target - cur, path);</span></span><br><span class="line">        <span class="comment">// path.remove(path.size()-1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿了原地不动</span></span><br><span class="line">        path.add(cur);</span><br><span class="line">        find(candidates, idx, target - cur, path);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不拿往下走</span></span><br><span class="line">        find(candidates, idx+<span class="number">1</span>, target, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转图像</title>
      <link href="/2022/06/03/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
      <url>/2022/06/03/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a></p><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><span id="more"></span><p><img src="/2022/06/03/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/mat1.jpg" alt="mat1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p>思路：先旋转每一层，以首行的n-1个元素作为出发点，分别旋转（记录当前值，然后寻找需要放置到当前位置的值的位置，更新值并更新位置到计算的新位置。持续3次，最后一个位置以缓存值更新即可）。然后递归旋转内部即可。重要的地方：根据当前坐标计算需要替换值的坐标存在以下关系（与层级无关）：<code>[row, column] - &gt; [size - column - 1, row]</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        size = matrix.length;</span><br><span class="line">        rotate(matrix, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= size / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历到倒数第二个即可，最后一个会在第一个旋转时替换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level; i &lt; size - level - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> level;</span><br><span class="line">            <span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 缓存起点值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cache</span> <span class="operator">=</span> matrix[row][column];</span><br><span class="line">            <span class="comment">// 旋转3次，最后一次以缓存值更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>; m &lt; <span class="number">3</span>; m++) &#123;</span><br><span class="line">                <span class="comment">// 计算当前位置应由哪个位置的值来覆盖</span></span><br><span class="line">                <span class="type">int</span>[] pos =findBefore(row, column);</span><br><span class="line">                matrix[row][column] = matrix[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]];</span><br><span class="line">                <span class="comment">// 更新位置</span></span><br><span class="line">                row = pos[<span class="number">0</span>];</span><br><span class="line">                column = pos[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            matrix[row][column] = cache;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算内层</span></span><br><span class="line">        rotate(matrix, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findBefore(<span class="type">int</span> row, <span class="type">int</span> column)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;size-column-<span class="number">1</span>,row&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 迭代 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小路径和</title>
      <link href="/2022/06/02/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2022/06/02/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></p><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p>思路1: 递归，当前位置到结束的最小路径和等于往左往右走较小和加上当前路径值即可</p><p>代码（思路1）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        width = grid[<span class="number">0</span>].length;</span><br><span class="line">        height = grid.length;</span><br><span class="line">        <span class="keyword">return</span> minPath(grid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPath</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> row, <span class="type">int</span> column)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(row == height || column == width) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row == height-<span class="number">1</span> &amp;&amp; column == width-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> grid[row][column];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minPath(grid, row+<span class="number">1</span>, column);</span><br><span class="line">        <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> minPath(grid, row, column + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(right, down) + grid[row][column];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2: 思路1在leetcode中超时，所以通过dp来做，可以维护dp数组表示当前节点到结束的最短路径和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[height][width];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> height - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> width - <span class="number">1</span>; column &gt;= <span class="number">0</span>; column--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(row == height - <span class="number">1</span> &amp;&amp; column == width - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[row][column] = grid[row][column];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">                    <span class="keyword">if</span>(column &lt; width - <span class="number">1</span>)&#123;</span><br><span class="line">                        min = dp[row][column+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(row &lt; height - <span class="number">1</span>)&#123;</span><br><span class="line">                        min = Math.min(min, dp[row+<span class="number">1</span>][column]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[row][column] = min + grid[row][column];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的直径</title>
      <link href="/2022/06/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
      <url>/2022/06/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a></p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树</span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路1：计算最长路径，可以转化为求每个节点的作为根节点并该节点长度。并与全局变量max比较并更新。每个节点的最大长度等于其左子树最长的一条路径（左子树左右路径中较长的一条）+ 其右子树最长的一条路径（右子树左右路径中较长的一条）+ 1。 采用后续遍历，遍历过程中维护子树的左右子树最长路径，根据左右子树最长路径更新当前节点的左右最长路径。</p><p>官方思路：Max(max, 左子树深度+右子树深度+1) </p><p>思路1中的：”每个节点的最大长度等于其左子树最长的一条路径（左子树左右路径中较长的一条）+ 其右子树最长的一条路径（右子树左右路径中较长的一条）+ 1” 其实就是树的深度的意思，因为最终会遍历每一个节点作为根节点所以没必要维护左右子树的较大路径，直接用深度维护即可。</p><p>思路1代码（存在冗余代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] find(TreeNode node) &#123;</span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] lv = find(left);</span><br><span class="line">            ret[<span class="number">0</span>] = Math.max(lv[<span class="number">0</span>], lv[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] lr = find(right);</span><br><span class="line">            ret[<span class="number">1</span>] = Math.max(lr[<span class="number">0</span>], lr[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> ret[<span class="number">0</span>] + ret[<span class="number">1</span>] - min;</span><br><span class="line">        max = Math.max(max, l1);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> depth(node.left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> depth(node.right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = Math.max(ans, L+R+<span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：最长路径就是以每个节点作为根节点，计算经过根节点的最长路径即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路径总和 II</title>
      <link href="/2022/06/02/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/"/>
      <url>/2022/06/02/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/path-sum-ii/">路径总和 II</a></p><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><span id="more"></span><p><img src="/2022/06/02/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/pathsumii1.jpg" alt="pathsumii1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p>思路：求root节点开始到叶子节点和为target的路径，等于当前节点加上子节点到叶子节点和为：target - root.val的路径。采用先序遍历，在遍历过程维护当前路径与子路径并及时回退</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 全局结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 临时路径</span></span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        findPath(root, targetSum, tmp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPath</span><span class="params">(TreeNode node, <span class="type">int</span> target, List&lt;Integer&gt; tmp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="comment">// 添加当前节点路径</span></span><br><span class="line">        tmp.add(val);</span><br><span class="line">        <span class="comment">// 计算子节点需要满足的target</span></span><br><span class="line">        target -= val;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;  <span class="comment">// found matched</span></span><br><span class="line">                List&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                t.addAll(tmp);</span><br><span class="line">                result.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 找左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                findPath(node.left, target, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                findPath(node.right, target, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 回退临时路径</span></span><br><span class="line">        tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes基础概念</title>
      <link href="/2022/06/02/Kubernetes%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/06/02/Kubernetes%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Kubernetes"><a href="#什么是Kubernetes" class="headerlink" title="什么是Kubernetes"></a>什么是Kubernetes</h1><p>开源的容器管理平台。通过配置即可自动调度管理容器。拥有以下功能：</p><ul><li><strong>服务发现与负载均衡</strong> k8s可以通过DNS或者IP暴露容器服务并自动发现，如果对于容器服务请求过高，k8s可以进行负载均衡流量，使服务平稳运行</li><li><strong>存储编排</strong> 可以自由挂在存储资源，例如本地存储，云存储等</li><li><strong>自动状态更新</strong> 通过配置新的容器状态，随后k8s将创建新的容器并进行资源转移</li><li><strong>机器资源配置</strong> 可以为每个容器配置需要的CPU以及内存资源</li><li><strong>自愈</strong> 发现服务异常自动重启</li><li><strong>敏感信息配置</strong> 对于密码，token，keys等敏感信息由k8s私密管理</li></ul><span id="more"></span><h1 id="Kubernates集群组件"><a href="#Kubernates集群组件" class="headerlink" title="Kubernates集群组件"></a>Kubernates集群组件</h1><p>k8s集群包换了一些<code>worker</code>机器，被称为<code>nodes</code>。worker上会运行容器程序，每个集群至少有一个<code>worker</code>。<code>control plan</code>管理这些worker nodes 以及 Pods，通常在生产环境会运行于多个节点上。提供high availability服务。</p><p>组件：</p><p><img src="/2022/06/02/Kubernetes%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/components-of-kubernetes.svg" alt="components-of-kubernetes"></p><h2 id="Control-Plane-Components"><a href="#Control-Plane-Components" class="headerlink" title="Control Plane Components"></a>Control Plane Components</h2><p>Control Plane Components 主要用来做一些决策，例如启动新的副本如果副本数不足。一些请求事件响应，如创建了dployment就同步创建启动pod。通常情况下部署在相同节点下，并且不在该节点下运行用户容器。参考：<a href="https://kubernetes.io/docs/concepts/overview/components/">Kubbernetes Components</a></p><ul><li><p>kube-apiserver</p><p>用于暴露k8s api</p></li><li><p>etcd</p><p>高可用键值数据库</p></li><li><p>kube-scheduler</p><p>根据resource定义分配满足执行条件节点并运行</p></li><li><p>kube-controller-manager</p><p>运行控制器进程的控制组件。从逻辑上讲，每个控制器都是一个单独的进程，但为了降低复杂性，它们都编译成单个二进制文件并在单个进程中运行。</p><p>这些控制器的某些类型是：</p><ul><li><p>节点控制器：负责节点发生故障时的注意和响应。</p></li><li><p>作业控制器：监视表示一次性任务的作业对象，然后创建Pod来运行这些任务完成。</p></li><li><p>端点控制器：填充端点对象（即加入服务和Pod）。</p></li><li><p>服务帐户和令牌控制器：为新命名空间创建默认帐户和API访问令牌。</p></li></ul></li><li><p>cloud-controller-manager</p><p>可以将当前集群加入云集群，具体参考<a href="https://kubernetes.io/docs/concepts/overview/components/">Kubbernetes Components</a></p></li></ul><h2 id="Node-Components"><a href="#Node-Components" class="headerlink" title="Node Components"></a>Node Components</h2><ul><li>kubelet</li><li>kube-proxy</li><li>Container runtime</li></ul><h2 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a>Addons</h2><ul><li>DNS</li><li>Web UI（Dashboard）</li><li>Container Resource Monitoring</li><li>Cluster-level Logging</li></ul><h1 id="Kubernetes常用对象"><a href="#Kubernetes常用对象" class="headerlink" title="Kubernetes常用对象"></a>Kubernetes常用对象</h1><p>Kubernetes对象是Kubernetes系统中的持久实体。Kubernetes使用这些实体来表示集群的状态。具体来说，他们可以描述：</p><ul><li><p>正在运行哪些容器化应用程序（以及哪些节点）</p></li><li><p>这些应用程序可用的资源</p></li><li><p>围绕这些应用程序行为的策略，例如重新启动策略、升级和容错性</p></li></ul><p>Kubernetes对象是“意图记录”，一旦您创建对象，Kubernetes系统将不断工作以确保该对象的存在。通过创建对象，您可以有效地告诉Kubernetes系统您希望集群的工作负载是什么样子；这是集群所需的状态。</p><p>要使用Kubernetes对象，无论是创建、修改还是删除它们——您需要使用Kubernetes API。例如，当您使用kubectl命令行界面时，CLI会为您进行必要的Kubernetes API调用。您还可以使用客户端库之一直接在自己的程序中使用Kubernetes API。</p><h2 id="Object-Spec-and-Status"><a href="#Object-Spec-and-Status" class="headerlink" title="Object Spec and Status"></a>Object Spec and Status</h2><p>对象规格和状态</p><p>几乎每个Kubernetes对象都包含两个控制对象配置的嵌套对象字段：对象规范和对象状态。对于具有规范的对象，您必须在创建对象时设置此设置，并描述您希望资源具有的特征：其所需的状态。</p><p>该状态描述了对象的当前状态，由Kubernetes系统及其组件提供和更新。Kubernetes控制平面持续并主动地管理每个对象的实际状态，以匹配您提供的期望状态。</p><p>例如：在Kubernetes中，部署是一个可以表示在集群上运行的应用程序的对象。当您创建部署时，您可以将部署规范设置为指定您希望运行应用程序的三个副本。Kubernetes系统读取部署规范，并启动所需应用程序的三个实例——更新状态以匹配您的规范。如果其中任何实例出现故障（状态更改），Kubernetes系统会通过更正来响应规范和状态之间的差异——在这种情况下，启动替换实例。</p><p>有关对象规范、状态和元数据的更多信息，请参阅<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md">Kubernetes API Conventions</a>.</p><h2 id="Describing-a-Kubernetes-object"><a href="#Describing-a-Kubernetes-object" class="headerlink" title="Describing a Kubernetes object"></a>Describing a Kubernetes object</h2><p>当您在Kubernetes中创建对象时，您必须提供描述其所需状态的对象规范，以及有关对象的一些基本信息（例如名称）。当您使用Kubernetes API创建对象（直接或通过kubectl）时，该API请求必须在请求主体中包含该信息作为JSON。通常，您在.yaml文件中向kubectl提供信息。kubectl在提出API请求时将信息转换为JSON。</p><p>这里有一个.yaml文件示例，显示Kubernetes部署的必填字段和对象规范：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>可以使用<code>kubectl apply</code>命令创建Deployment</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/deployment.yaml</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># deployment.apps/nginx-deployment created</span></span><br></pre></td></tr></table></figure><h2 id="必须字段"><a href="#必须字段" class="headerlink" title="必须字段"></a>必须字段</h2><p>在您要创建的Kubernetes对象的.yaml文件中，您需要为以下字段设置值：</p><ul><li><p>apiVersion - 您正在使用哪个版本的Kubernetes API来创建此对象</p></li><li><p>kind - 您想创建哪种对象</p></li><li><p>metadata - 有助于唯一识别对象的数据，包括名称字符串、UID和可选命名空间</p></li><li><p>spec - 您希望对象处于什么状态</p></li><li><p>对象规范的精确格式对每个Kubernetes对象都不同，并包含特定于该对象的嵌套字段。Kubernetes API参考可以帮助您找到可以使用Kubernetes创建的所有对象的规范格式。</p></li></ul><p>例如，请参阅Pod API参考的规范字段。对于每个Pod，.spec字段指定pod及其所需状态（例如该pod中每个容器的容器映像名称）。对象规范的另一个例子是StatefulSet API的规范字段。对于StatefulSet，.spec字段指定StatefulSet及其所需状态。在StatefulSet的.spec中是Pod对象的模板。该模板描述了StatefulSet控制器为满足StatefulSet规范而创建的Pod。不同类型的对象也可以具有不同的.status；同样，API参考页面详细说明了该.status字段的结构，以及每种不同类型对象的内容。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>namespace</li><li>node</li><li>pod</li><li>deployment</li><li>service</li><li>volumn</li></ul><h1 id="待补充。。。。。。"><a href="#待补充。。。。。。" class="headerlink" title="待补充。。。。。。"></a>待补充。。。。。。</h1>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证二叉搜索树</title>
      <link href="/2022/06/02/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2022/06/02/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></p><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><span id="more"></span><p><img src="/2022/06/02/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/tree1.jpg" alt="tree1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>思路：判断二叉搜索树合法，需要根节点判断左右子树最大最小节点满足题目关系。可以维护一个子节点值范围（递归子节点时维护并判断当前节点合法性），通过此范围与根节点值判断。从而判断该节点是否合法。</p><p><strong>递归思路：先自顶向下分析，然后分析底层边界逻辑反向验证，然后开始实现。</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Integer[] vals = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> isValid(root, vals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * root：要判断合法的子树根节点</span></span><br><span class="line"><span class="comment">     * vals：该子树值范围</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(TreeNode root, Integer[] vals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于叶子节点还是其他都出实话当前值作为范围</span></span><br><span class="line">        vals[<span class="number">0</span>] = root.val;</span><br><span class="line">        vals[<span class="number">1</span>] = root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处用一个新的对象，防止污染当前节点范围</span></span><br><span class="line">            Integer[] tval = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValid(root.left, tval);</span><br><span class="line">            <span class="keyword">if</span>(!left) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= tval[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tval[<span class="number">1</span>] &gt;= root.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以左子树范围更新当前节点范围，如果上面条件通过则树合法，以子树范围更新可以扩大当前子树值范围</span></span><br><span class="line">            vals[<span class="number">0</span>] = tval[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            Integer[] tval = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValid(root.right, tval);</span><br><span class="line">            <span class="keyword">if</span>(!right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt;= tval[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tval[<span class="number">0</span>] &lt;= root.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vals[<span class="number">1</span>] = tval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小覆盖子串</title>
      <link href="/2022/06/01/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/06/01/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖字串</a></p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><span id="more"></span><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p>思路：采用滑动窗口，通过hash <code>t</code>字符串每个字符的频率，同样在滑动窗口调整时维护<code>s</code>的字符频率hash。关于窗口的调整策略：先调整右边界，直到所有节点都已包含，可以更新最小长度。然后调整左边界，如果移动后依旧包含则更新最小长度。如果不包含调整右边界直至继续包含目标串。按照这个策略调整窗口并更新<code>s</code>的hash。右边界在移动的时候如果能保持hash数量大于t串hash对应数量则表示包含。另外全部包含需要一个额外变量存储length，通过每一次窗口调整更新该变量，如果该变量长度等于<code>t</code>串长度则表示已全包含（更新策略，如果右边界判断hash数量大于t串hash对应数量，则length + t中该字符数量，如果左边界判断hash数量小于t串hash对应数量，则length - 1）。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待补充。。。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leedcode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长有效括号</title>
      <link href="/2022/06/01/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/2022/06/01/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></p><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br><span class="line"></span><br><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>思路：</p><ol><li><p>暴力</p><p>遍历数组，以每一个索引开始寻找最长的合法括号串。然后找出最大的长度返回</p></li><li><p>dp</p><p>定义：dp[i]：以索引<code>i</code>结尾的元素的最长合法括号串</p><p>存在以下递推关系：</p><p>dp[i] &#x3D; dp[i-2] + 2  &#x2F;&#x2F; 如果str[i] 与 str[i - 1] 为：<code>()</code></p><p>dp[i] &#x3D; dp[i-1] + 2 + dp[i - 2 - dp[i-1]]  &#x2F;&#x2F; 如果str[i] &#x3D; <code>&#39;)&#39;</code> &amp;&amp; str[i - dp[i-1] - 1] &#x3D; <code>&#39;(&#39;</code></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span> sc[] = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">// 状况1</span></span><br><span class="line">            <span class="keyword">if</span>(sc[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;sc[i-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> i-<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 更新dp</span></span><br><span class="line">                    dp[i] = dp[pos] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 状况2</span></span><br><span class="line">            <span class="keyword">if</span>(sc[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;sc[i-<span class="number">1</span>]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> i-dp[i-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(pos&gt;=<span class="number">0</span>&amp;&amp;sc[pos]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// 更新dp</span></span><br><span class="line">                    dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// 加前面的 重要：((()))(()), 如果此时索引为9，dp[i-1] = 2 (), 前面需要加的就是((()))</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i-<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;pos-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i] += dp[pos-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零钱兑换</title>
      <link href="/2022/06/01/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>/2022/06/01/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></p><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>思路：dp[amount]，计算每个amount的关于提供硬币的所需硬币数量：针对提供的硬币数组，计算从0～amount的dp数组。存在这样的关系：</p><ul><li>需要计算每一个金额最小的硬币数</li><li>遍历每一个硬币，如果可以大于要组成的amount，直接continue（无法通过这个硬币组成该金额）</li><li>小于amount，组成amount的硬币个数为：dp[amount - coinAmount] + 1（需要注意，如果dp[amount - coinAmount] 为-1，即无法组成该amount硬币组合，直接continue）</li><li>对于每种组合，求最小的进行赋值：dp[amount] &#x3D; min(dp[amount - coinAmount] ) + 1</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">am</span> <span class="operator">=</span> <span class="number">1</span>; am &lt;= amount; am++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">other</span> <span class="operator">=</span> am - coin;</span><br><span class="line">                <span class="keyword">if</span>(other &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果硬币面值过大，直接丢弃这种组合方式</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 表示没有这种组合方式，丢弃</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[other] == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 首次直接赋值，后续需要取较小值更新</span></span><br><span class="line">                    count = count == <span class="literal">null</span> ? dp[other] + <span class="number">1</span> : Math.min(count,dp[other] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[am] = count == <span class="literal">null</span> ? -<span class="number">1</span> : count;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAFT算法</title>
      <link href="/2022/06/01/RAFT%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/01/RAFT%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RESTful</title>
      <link href="/2022/06/01/RESTful/"/>
      <url>/2022/06/01/RESTful/</url>
      
        <content type="html"><![CDATA[<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><h2 id="Resource-Representational-State-Transfer："><a href="#Resource-Representational-State-Transfer：" class="headerlink" title="Resource Representational State Transfer："></a><code>Resource Representational State Transfer</code>：</h2><ul><li><strong>资源（Resource）</strong> ：URL即资源，指向具体操作的对象</li><li><strong>表现形式（Representational）</strong>：请求数据类型（<code>json</code>, <code>xml</code>,<code>file</code>等）</li><li><strong>状态转移（State Transfer）</strong> ：通过具体的<code>method</code>行为（<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>PATCH</code>,<code>DELETE</code>）操作资源并改变资源状态</li></ul><span id="more"></span><h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><ul><li><code>GET</code> 获取资源</li><li><code>POST</code> 保存资源</li><li><code>PUT</code> 更新资源（全量更新）</li><li><code>PATCH</code> 更新资源（部分更新）</li><li><code>DELETE</code> 删除资源</li></ul><h2 id="URL设计规则"><a href="#URL设计规则" class="headerlink" title="URL设计规则"></a>URL设计规则</h2><ul><li>不可包含动词，仅描述资源</li><li>使用小写字母</li><li>设置版本号规则，实现版本化</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h1><p><code>Hypermedia as the Engine of Application State</code></p><p>可以被简单的理解为为 REST API 中的 Resource 提供必要的链接，对，就像是 HTML 页面上的链接。我们在访问一个 web 站点的时候从来没有说要看一个说明文档并在其中找到我们所需要的资源的 URI，而是通过一个入口页面（当然，搜索引擎也提供了入口）所包含的链接，一步一步找到我们想要的内容。HATEOAS 是 REST 架构风格重要的组成部分，然而对于现在的诸多 REST 接口中却并没有它的身影。它被 <a href="https://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a> 定义为 REST 的最终形态。<a href="https://blog.aisensiy.me/2017/06/04/spring-boot-and-hateoas/">参考链接</a></p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>参考1：<a href="https://spring.io/guides/tutorials/rest/">SpringBoot Restful</a></p><p>参考2：<a href="https://blog.aisensiy.me/2017/06/04/spring-boot-and-hateoas/">SpringBoot &amp; HATEOAS</a></p><p>参考3：<a href="https://docs.spring.io/spring-hateoas/docs/1.5.0/reference/html/">Spring HATEOAS</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> RESTful </tag>
            
            <tag> HATEOAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口最大值</title>
      <link href="/2022/05/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2022/05/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a></p><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><span id="more"></span><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p><p>思路：维护一个单调递减栈（如果区间内来了一个更大的值，之前的都不参与计算最大值。但是如果来一个较小的数，如果大数走出区间这个小一点的数就要参与计算最大值）。每次到达区间新值时计算当前区间最大值更新即可。此处注意栈是后进先出，由于是递减栈，所以我们要找的肯定在栈底部更接近，此处由于java的Stack类继承Vector可以通过迭代器从底部遍历，从而节省性能。还有需要注意走过的区间要将入栈的数据删掉，节省下次寻找区间最值的时间。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[length - k + <span class="number">1</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; length) &#123;</span><br><span class="line">             <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[index] &gt; nums[stack.peek()]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(index);</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                ret[retIndex] = findMax(stack,nums, index - k + <span class="number">1</span>);</span><br><span class="line">                retIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(Stack&lt;Integer&gt; stack,<span class="type">int</span>[] nums, <span class="type">int</span> minIndex)</span>&#123;</span><br><span class="line">        <span class="comment">// 此处用迭代器，可以从最早push的数据开始检索</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = stack.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(s &gt;= minIndex) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[s];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// remove掉不会再参与计算的数据，节省内存并减少下次遍历时间</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从前序与中序遍历序列构造二叉树</title>
      <link href="/2022/05/31/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/05/31/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></p><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><span id="more"></span><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]</p><p>思路：</p><p>可以按照先序遍历顺序构建节点，第一个节点是整棵树的根节点。后续每个节点在中序遍历数组中确认其左右子树范围递归构建左右子树（可以将中序遍历数组做成Map方便查找确定范围）。需要注意的：递归过程中先序遍历索引更新</p><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; inordreMap = buildMap(inorder);</span><br><span class="line">        <span class="keyword">return</span> build(preorder, inordreMap,<span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, Map&lt;Integer,Integer&gt;  inorder, <span class="type">int</span> is, <span class="type">int</span> ie)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ps &gt;= preorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[ps];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> inorder.get(val);</span><br><span class="line">        <span class="keyword">if</span>(index &gt; is)&#123;</span><br><span class="line">            ps++;</span><br><span class="line">            node.left = build(preorder, inorder,is, index-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; ie)&#123;</span><br><span class="line">            ps++;</span><br><span class="line">            node.right = build(preorder, inorder,index+<span class="number">1</span>, ie);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer,Integer&gt; <span class="title function_">buildMap</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            ret.put(arr[i],i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch和CycilBarrier</title>
      <link href="/2022/05/31/CountDownLatch%E5%92%8CCycilBarrier/"/>
      <url>/2022/05/31/CountDownLatch%E5%92%8CCycilBarrier/</url>
      
        <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>内部采用AQS实现，初始化时设置State。</p><p><code>countDown()</code>方法调用时调用<code>tryRelease()</code>将state减一并通过CAS更新state；</p><p><code>await()</code>主线程调用时，会判断state是否为0，是0的话直接退出，否则加入AQS队列等待唤醒。</p><span id="more"></span><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>借助 ReentrantLock的Condition等待唤醒实现。</p><p>在构建CyclicBarrier时，传入的值会赋值给CyclicBarrier内部维护count变量，也会赋值给parties变量（这是可以复用的关键）</p><p>每次调用await时，会将count -1 ，操作count值是直接使用ReentrantLock来保证线程安全性；</p><p>如果count不为0，则添加则condition队列中</p><p>如果count等于0时，则把节点从condition队列添加至AQS的队列中进行全部唤醒，并且将parties的值重新赋值为count的值（实现复用）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CountDownlatch基于AQS实现，会将构造CountDownLatch的入参传递至state，countDown()就是在利用CAS将state减-1，await()实际就是让头节点一直在等待state为0时，释放等待的线程</p><p>CyclicBarrier则利用ReentrantLock和Condition，自身维护了count和parties变量。每次调用await将count-1，并将线程加入到condition队列上。等到count为0时，则将condition队列的节点移交至AQS队列，并全部释放。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 线程同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLoacl</title>
      <link href="/2022/05/31/ThreadLoacl/"/>
      <url>/2022/05/31/ThreadLoacl/</url>
      
        <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;T&gt; res1 = <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;T&gt; res2 = <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;resource2&quot;</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ThreadLocal是一个壳子，真正的存储结构是ThreadLocal里有ThreadLocalMap这么个内部类。</p><p>ThreadLocalMap的引用是在Thread上定义的</p><p>ThreadLocal本身并不存储值，它只是作为key（弱引用）来让线程从ThreadLocalMap获取value</p><p><img src="/2022/05/31/ThreadLoacl/image-20220531114220950.png" alt="image-20220531114220950"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><p>为什么不用Thread作为key存取数据？这样更直观</p><p>thread作为key则所有线程数据在一个大Map中</p><ul><li>不方便维护，一个大map。</li><li>一个线程多个值需要存取，只能在value上做文章。</li><li>Map不能无限膨胀</li></ul></li><li><p>内存泄漏问题是什么？什么时候会发生？如何避免？</p><p>ThreadLocalMap的Key是一个弱引用指向ThreadLocal实例。此时正常情况有两个引用指向ThreadLocal实例，一个强引用和一个弱引用。如果强引用被回收掉，ThreadLocal对象只有一个弱引用，也会被回收掉。此时ThreadLocalMap中key为null。到那时value并未被回收，如果在线程池下使用ThreadLocal并且对于key无新操作（因为ThreadLocal在每次操作时会自动清理key为null的value）就会存在大量value未回收的情况。</p><p><img src="/2022/05/31/ThreadLoacl/640.jpeg" alt="640"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2022/05/31/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/05/31/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h1><p>ThreadPoolExecutor创建，了解线程创建参数避免资源耗尽。</p><span id="more"></span><h1 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h1><ul><li>核心线程数</li><li>最大线程数</li><li>线程空闲时间</li><li>阻塞队列<ul><li><code>ArrayBlockingQueue</code></li><li><code>LinkedBlockingQuewue</code></li><li><code>PriorityBlockingQueue</code></li></ul></li><li>拒绝策略<ul><li>丢弃任务并抛异常</li><li>直接丢掉新任务</li><li>丢掉队列中最早的任务</li><li>提交任务的线程执行该任务</li></ul></li></ul><h1 id="任务提交执行流程"><a href="#任务提交执行流程" class="headerlink" title="任务提交执行流程"></a>任务提交执行流程</h1><ol><li>提交任务</li><li>判断当前线程数是否小雨核心线程，如果小于则创建核心线程执行</li><li>否则判断阻塞队列是否已满，如果已满执行4，否则5</li><li>判断当前线程数是否达到最大线程数，如果达到则触发拒绝策略，否则创建新线程执行</li><li>加入阻塞队列即可</li></ol><h1 id="参数设计"><a href="#参数设计" class="headerlink" title="参数设计"></a>参数设计</h1><ol><li><p>根据任务类型设计：</p><p><strong>CPU密集型</strong>：与CPU核心数1～2倍。（不设置过多是CPU已经占用很高，避免无意义的上下文切换）</p><p><strong>IO密集型</strong>：采用《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法：<strong>线程数 &#x3D; CPU 核心数 *（1+平均等待时间&#x2F;平均工作时间）</strong></p></li><li><p>压测确定</p><p>为了更准确的参数配置，可以通过压测来确定服务的最佳线程数量。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS</title>
      <link href="/2022/05/31/AQS/"/>
      <url>/2022/05/31/AQS/</url>
      
        <content type="html"><![CDATA[<p>AbstractQueueSynchroinzer。提供了一个锁框架。内部有一个Integer类型state和一个双向队列。封装了线程锁请求入FIFO双向队列入队出队以及线程挂起唤醒等过程，实现线程安全。</p><span id="more"></span><h1 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a><strong>两种模式</strong></h1><p>独占：State作为一个独占资源</p><p>共享：State的32位拆分为多个资源。</p><h1 id="公平非公平"><a href="#公平非公平" class="headerlink" title="公平非公平"></a><strong>公平非公平</strong></h1><p>公平锁：通过FIFO队列，新锁请求放入队尾</p><p>非公平锁：锁请求先尝试获取锁，获取失败再入队列</p><h1 id="加锁执行流程（独占非公平锁为例）"><a href="#加锁执行流程（独占非公平锁为例）" class="headerlink" title="加锁执行流程（独占非公平锁为例）"></a><strong>加锁执行流程</strong>（独占非公平锁为例）</h1><ul><li>调用<code>lock()</code>方法</li><li>CAS尝试修改State获取锁</li><li>获取锁成功</li><li>获取失败，加入锁队列，前驱节点设置为<code>Signal</code>状态（有后继节点需要唤醒），挂起当前线程</li><li>等待前驱节点获取锁唤醒执行后，唤醒后继线程获取锁继续执行</li></ul><h1 id="解锁执行流程"><a href="#解锁执行流程" class="headerlink" title="解锁执行流程"></a><strong>解锁执行流程</strong></h1><ul><li>调用<code>unlock()</code>方法</li><li>CAS尝试修改State</li><li>修改成功释放锁</li><li>唤醒下一个节点</li></ul><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// await</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  condition.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  condition.signal();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Condition内部维护条件队列（单向链表）。当调用<code>awit()</code>时，加入条件队列中。调用<code>signal()</code>时将头节点转移到AQS队列尾部，等待唤醒执行。<code>signalAll()</code>会将所有条件队列的节点计入AQS队列。</p><h1 id="Synchronized-VS-AQS"><a href="#Synchronized-VS-AQS" class="headerlink" title="Synchronized VS AQS"></a>Synchronized VS AQS</h1><ul><li>Synchronized 无需手动解锁，AQS需要</li><li>Synchronized膨胀为重量级锁后无法回退，AQS会自适应调整</li><li>Synchronized 的wait&#x2F;notifyAll没有AQS Condition灵活</li><li>AQS可中断锁</li><li>AQS可以实现公平锁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AQS </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized</title>
      <link href="/2022/05/31/Synchronized/"/>
      <url>/2022/05/31/Synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Synchronized是Java的一个关键字，通过它可以实现线程安全。</p><span id="more"></span><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><ol><li><p>修饰实例方法</p><p>将实例作为锁对象</p></li><li><p>修饰静态方法与静态代码块</p><p>将Class对象作为锁对象</p></li><li><p>自定义锁对象</p></li></ol><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>编译过程中会生成<code>monitorenter</code>与<code>monitorexit</code>字节码指令。锁信息会记录在锁对象的对象头中的Mark Word中</p><h1 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h1><p>参考：<a href="https://blog.csdn.net/qq_41860497/article/details/125010798#:~:text=%E5%81%8F%E5%90%91%E9%94%81%E6%98%AF%E6%8C%87%E5%BD%93%E4%B8%80%E6%AE%B5%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%B8%80%E7%9B%B4%E8%A2%AB%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%80%E8%AE%BF%E9%97%AE%E6%97%B6%EF%BC%8C%E5%8D%B3%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AB%9E%E4%BA%89%E6%97%B6%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5%E7%BA%BF%E7%A8%8B%E5%9C%A8%E5%90%8E%E7%BB%AD%E8%AE%BF%E9%97%AE%E6%97%B6%E4%BE%BF%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%BE%97%E9%94%81%EF%BC%8C%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E8%8E%B7%E5%8F%96%E9%94%81%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%B6%88%E8%80%97%EF%BC%8C%E5%8D%B3%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%82%20%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%B9%B6%E8%8E%B7%E5%8F%96%E9%94%81%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%9C%A8%20Mark%20Word,%E9%87%8C%E5%AD%98%E5%82%A8%E9%94%81%E5%81%8F%E5%90%91%E7%9A%84%20%E7%BA%BF%E7%A8%8B%20ID%20%E3%80%82">锁升级过程</a></p><p>最初Synchronized是采用重量级锁，重量级锁存在内核态与用户态的切换，存在性能损耗。于是后续进行了相关优化：锁升级</p><p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p><p>偏向锁：偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。线程尝试竞争时，偏向锁等待全局安全点判断是否有竞争恢复到轻量级锁或无锁状态。<strong>偏向锁适用于同一个线程多次获取锁的情况</strong>。 <strong>缺点：竞争激烈情况下，存在锁撤销的开销，此时可以关闭偏向锁</strong></p><p>轻量级锁：<strong>适用于多个线程交替获取锁，很少发生竞争</strong>， <strong>缺点：消耗CPU</strong></p><p>重量级锁：<strong>系统中存在大量的线程同时尝试获取锁，高并发场景</strong>，<strong>缺点：线程阻塞唤醒，频繁切换上下文性能损耗</strong></p><p>详细过程：</p><ol><li>尝试获取锁的线程，检查锁对象头中Mark Word记录的线程ID。如果与当前线程ID相同，表示已获取锁直接执行</li><li>如果发现与当前线程不一致，偏向锁撤销升级为轻量级锁。拷贝Mark Word到栈帧，尝试CAS自旋修改Mark Word指向栈帧，修改成功则获得锁，否则在多次（15次）自旋失败后膨胀为重量级锁</li><li>此时存在大量竞争，未保证线程安全并且降低自旋导致的cpu busy。重量级锁接管，对于未获取锁的线程进行阻塞。等待锁释放操作系统调度。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 线程安全 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
            <tag> java </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomInteger与LongAdder</title>
      <link href="/2022/05/31/AtomInteger%E4%B8%8ELongAdder/"/>
      <url>/2022/05/31/AtomInteger%E4%B8%8ELongAdder/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>Compare And Swap：通过原子的进行比较交换操作保证数据安全。</p><p>具体流程：每次更新前先判断当前值是否相等，如果相等就进行替换。否则自旋等待锁释放。</p><p>存在问题：ABA问题，就是存在另外线程将值改回之前的值，此时另一个不该获取锁的线程可以拿到锁</p><p>如何避免：通过对信息加版本号，例如：使用AtomicStampedReference作为版本信息保证不会回退旧数据</p><span id="more"></span><h1 id="AtomInteger"><a href="#AtomInteger" class="headerlink" title="AtomInteger"></a>AtomInteger</h1><p>底层通过CAS，能够原子的进行累加，保证线程安全。</p><p>缺点：只有一个共享资源，高并发下大部分线程自旋等待。性能不佳</p><p>改进：使用<code>LongAdder</code></p><h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p>底层同样采用CAS，但是内部类似分段锁机制通过一个Cell数据将资源划分开，降低失败次数并减小自旋性能损失。所以在高并发情况下推荐使用<code>LongAdder</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线程安全 </tag>
            
            <tag> AtomInteger </tag>
            
            <tag> LongAdder </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="/2022/05/31/%E6%AD%BB%E9%94%81/"/>
      <url>/2022/05/31/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h1><p>多线程情况下，线程互相拥有对方需要的资源从而相互等待资源释放，从而导致程序无法继续进行造成死锁。</p><span id="more"></span><h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><ol><li><p>固定枷锁顺序</p><p>可以通过业务字段运算排序确定加锁的顺序</p></li><li><p>尽可能减小锁的范围</p><p>等到操作共享变量时再加锁，降低死锁概率</p></li><li><p>定时锁</p><p>一段时间获取不到锁，释放掉</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO</title>
      <link href="/2022/05/31/Java-IO/"/>
      <url>/2022/05/31/Java-IO/</url>
      
        <content type="html"><![CDATA[<h1 id="BIO-gt-NIO"><a href="#BIO-gt-NIO" class="headerlink" title="BIO -&gt; NIO"></a>BIO -&gt; NIO</h1><blockquote><p> BIO： Blocking IO 阻塞IO，按字节进行处理</p><p>NIO：No-Blocking IO（New-IO），非阻塞。按缓冲区处理</p></blockquote><span id="more"></span><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>3个组件：</p><ul><li>Selector：检查Channel状态变化</li><li>Channel：运输数据通道</li><li>Buffer：数据存储</li></ul><p>零拷贝：</p><ul><li><p>mmap（内核缓冲区与用户缓冲区的共享）</p></li><li><p>sendfile（系统底层函数支持）</p></li></ul><h1 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h1><p>select，poll，epoll</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 图片</title>
      <link href="/2022/05/30/Hexo-%E5%9B%BE%E7%89%87/"/>
      <url>/2022/05/30/Hexo-%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></p><span id="more"></span><p><img src="/2022/05/30/Hexo-%E5%9B%BE%E7%89%87/20200707101943_hCjji.jpeg" alt="20200707101943_hCjji"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/2022/05/30/Java-%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/30/Java-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h1><ul><li>面向对象（封装、继承、多态）</li><li>跨平台</li><li>多线程支持</li><li>编译与解释执行（class文件编译与JIT即时编译（编译为机器码），JVM执行时解释执行）</li></ul><span id="more"></span><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol><li><p>基础数据类型</p><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td><td>-32768 ~ 32767</td></tr><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘u0000’</td><td>0 ~ 65535</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td><code>boolean</code></td><td>1</td><td></td><td>false</td><td>true、false</td></tr></tbody></table><p>注意：boolean长度为明确。取决于JVM实现，逻辑上是占用1位。</p></li><li><p>自动拆装箱</p><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><ol><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ol></li><li><p>局部变量与成员变量</p><p>局部变量通常在栈中，随方法调用结束而回收。无默认值需设置；</p><p>成员变量通常在堆中，随对象创建而存在。有默认值。</p></li><li><p>集合</p><p>List，Map，Set以及线程安全相关集合</p><p>集合操作参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/collection/java-collection-precautions-for-use.md">https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/collection/java-collection-precautions-for-use.md</a></p></li><li><p>并发</p></li><li><p>异常</p><p>共同祖先：java.lang.Throwable</p><p>重要子类：Exception与Error</p><p><strong><code>Exception</code></strong> ：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p><ul><li>Checked Excpetion:<ul><li>IOException</li><li>ClassNotFoundException</li><li>SQLException</li><li>FileNotFoundException</li></ul></li><li>Unchecked Exception:<ul><li>ArithmeticException</li><li>ClassCastException</li><li>NullPointException</li><li>IllegalThreadStateException</li><li>IndexOutOfBoundsException</li></ul></li></ul><p>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误 ，<del>我们没办法通过 <code>catch</code> 来进行捕获</del>不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p><ul><li>OutOfMemoryError</li><li>StackOverFlowError</li><li>AssertionError</li><li>VritualMachineError</li></ul><p>注意：不要再finally中使用return！在try中return返回值会放在一个本地变量中，后续执行到finally中的return，会覆盖并返回。</p><p>JVM官方文档明确提到：</p><p>If the <code>try</code> clause executes a <em>return</em>, the compiled code does the following:</p><ol><li>Saves the return value (if any) in a local variable.</li><li>Executes a <em>jsr</em> to the code for the <code>finally</code> clause.</li><li>Upon return from the <code>finally</code> clause, returns the value saved in the local variable.</li></ol><p>异常使用规范：异常信息有意义；日志打印异常与抛出异常不要并存。</p></li><li><p>泛型</p><p>一套工具适配多种类型</p><p>提供编译时检查避免错误</p><p>泛型擦出：运行时泛型会去掉</p></li><li><p>反射</p><p>优点：灵活</p><p>缺点：性能问题，参考：<a href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow">https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow</a></p><p>应用场景：各种框架配置与调用都有用到反射。</p></li><li><p>IO</p><p>操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p><ul><li><p>BIO</p><ul><li><p>同步阻塞 I&#x2F;O</p><p>阻塞每次读写，等到内核态数据拷贝完成返回。</p></li><li><p>同步非阻塞 I&#x2F;O</p><p>多次读取不阻塞，内核态数据拷贝时时阻塞。</p></li></ul></li><li><p>NIO</p><ul><li><p>select </p><p>维护很多socket连接（创建链接时维护socket集合），通过询问内核是否已准备好数据，如果准备好再发器read（读取过程依旧是阻塞的），内核轮询socket集合，找到准备完成的socket进行数据读取（可能只有部分socket活跃，每次轮训耗时长且无意义）。每次需要将socket集合传递给内核，有一定开销。进程被唤醒拿到相应还需要遍历确定哪个socket收到数据，共需要两次遍历。select有最大文件描述符数量限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">           fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure></li><li><p>pool 同select，但是无最大文件描述符限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fds[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>；</span><br></pre></td></tr></table></figure></li><li><p>epool</p><p>基于事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">rdllink</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>  *<span class="title">next</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  </span><br><span class="line">  <span class="type">int</span>  nwait;                 </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">pwqlist</span>;</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>  *<span class="title">ep</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">fllink</span>;</span>   </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>  <span class="title">event</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">  <span class="type">spin_lock_t</span>       lock; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>      <span class="title">mtx</span>;</span>  </span><br><span class="line">  <span class="type">wait_queue_head_t</span>     wq; </span><br><span class="line">  <span class="type">wait_queue_head_t</span>   poll_wait; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllist</span>;</span>   <span class="comment">//就绪链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>      <span class="title">rbr</span>;</span>      <span class="comment">//红黑树根节点 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>      *<span class="title">ovflist</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户数据载体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>    *ptr;</span><br><span class="line">   <span class="type">int</span>      fd;</span><br><span class="line">   <span class="type">uint32_t</span> u32;</span><br><span class="line">   <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="comment">//fd装载入内核的载体</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="type">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="type">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//三板斧api</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>AIO</p><p>拿回数据异步</p></li></ul><p>参考链接：<a href="https://www.jianshu.com/p/722819425dbd">https://www.jianshu.com/p/722819425dbd</a></p><ol start="10"><li><p>JVM</p><p>可以先看看这个：<a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/jvm/jvm-intro.md">https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/jvm/jvm-intro.md</a></p><ul><li>内存分配</li></ul><p>堆：eden区，2个suvivor区，old区。对象创建会在eden创建，经过一次回收会搬到suvivor区，后续每经过一次回收对象年龄加一，直到到达老年代阈值（默认15岁），对象进入老年代。老年代阈值会根据配置动态计算。</p><p>栈：本地方法栈、虚拟机栈以及程序计数器</p><p>方法区：加载的类信息以及运行时常量池以及JIT编译代码缓存。字符串常量池与静态变量均在堆中。</p><p>参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/jvm/memory-area.md">https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/jvm/memory-area.md</a></p><ul><li><p>对象创建流程</p><ol><li><p>类加载</p><p>检查是否已加载过，如果没有进行类加载</p></li><li><p>申请内存</p><p>类加载完成即可确定需要的内存，随后便申请内存分配</p><p>分配策略：</p><ul><li><p>指针碰撞</p><p>维护一个指针，区分已使用空间与未使用空间。</p></li><li><p>空闲列表</p><p>维护一个列表，记录哪些内存块可用</p></li></ul><p>并发分配内存：</p><ul><li>CAS+失败重试：通过CAS保证操作原子性</li><li>TLAB（Thread Local Allocation Buffer：本地分配缓存区，在线程初始化时申请Eden一部分空间）：分配内存时先在TLAB分配，到达一定量后通过CAS刷新到堆上。缺点：空间较小大对象无法适配。</li></ul></li><li><p>类初始化</p><ul><li><p>初始化零值</p><p>设置初始值，对象头不调整</p></li><li><p>设置对象头</p><p><strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></li><li><p>init方法执行</p></li></ul></li></ol></li><li><p>对象内存布局</p><p>对象头，实例数据，对齐填充</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p></li><li><p>对象访问方式</p><p>句柄和直接指针</p><ul><li><p>句柄指向句柄池数据（堆），再由句柄池指向实例数据（堆）和对象类型数据（栈）</p></li><li><p>直接指针直接执行对象实例数据（堆），其对象头存在指向对象类型数据（栈）的指针</p></li></ul><p>优缺点：句柄在对象变化过程后用户的引用无需变化，而直接指针需要变化。但是直接指针少一次指针定位开销，速度更快。</p></li><li><p>类加载模型</p><p>双亲委托</p><p>如果自定义类加载器：继承<code>ClassLoader</code>，重写<code>findClass()</code>方法，如果需要打破双亲委托，则需要重写<code>loadClass()</code>方法</p></li><li><p>JVM参数与优化</p><p>参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/jvm/jvm-parameters-intro.md">https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/jvm/jvm-parameters-intro.md</a></p></li></ul></li></ol></li></ol><h1 id="面试问题整理"><a href="#面试问题整理" class="headerlink" title="面试问题整理"></a>面试问题整理</h1><ol><li><p>字符型常量与字符串常量的区别？</p><p>字符常量相当于一个整形ASCII值，可以参与运算；字符串是内存地址。字符串常量2个字节；字符串若干个字节</p></li><li><p>重写遵循规范</p><ol><li>方法名，形参需要相同</li><li>返回值类型以及声明异常均小于或等于父类方法</li><li>访问权限需大于或等于父类方法</li></ol></li><li><p>可变长参数</p><p>可以传入不等长参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的：如果方法重载，固定参数方法优先级会高于变长参数方法</p></li><li><p>基本数据类型与包装类的区别？</p><ol><li>包装类型默认值null</li><li>包装类型可用于泛型</li><li>基本数据类型局部变量存储与Java虚拟机栈局部变量表中，基本数据类型的成员变量存在堆中，包装类型都在堆中</li></ol></li><li><p>构造方否可以override？</p><p>不能override，可以overload</p></li><li><p>java 9为何将String底层由 char[] 改成了 byte[] ?</p><p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p></li><li><p>String采用运算符“+”拼接为何耗费内存？</p><p>内部采用StringBuillder.append() 方法实现，拼接完后调用toString() 得到Stirng对象。这样就会存在大量的StringBuilder对象。</p></li><li><p>字符串常量池什么作用？</p><p>创建字符串后会在堆中创建具体对象，然后在常量池中创建对应的引用。访问字符串是直接返回常量池中的引用即可。字节码命令“ldc” 可以判断字符串常量池是否保存对应的字符串对象引用。</p></li><li><p>intern方法作用</p><p>native方法：如果字符串常量池不包含字符串饮用添加。然后返回字符串引用。</p></li><li><p>常量折叠</p><p>对于源代码中存在的可以确定的static final修饰的基础变量数据类型以及String，会对其进行计算并作为常量嵌入最终生成代码中。这事javac编译器做的优化</p></li><li><p>finally代码一定执行吗？</p><p>不一定！虚拟机异常终止便不会执行了。比如调用：System.exit(1); 还有所在线程死亡，CPU停止执行。</p></li><li><p>Java只有值传递吗？</p><p>是的，无论是基础类型还是引用类型。如果要修改对象值，通过引用修改即可。</p></li><li><p>通过类加载器与Class.forName()差异</p><p>Class.forName() 可以指定是否初始化Class，类加载器不会初始化。如果不出实话静态代码不会得到执行。</p></li><li><p>精度丢失与BigDecimal</p><p>由于float，double等表示小数时由于二进制存储原理，对于一些小数没有精确的2进制表示形式所以存在精度丢失。BigDecimal实现利用了BigInteger，并加入小数位的概念实现避免了精读丢失。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目介绍之亮点与难点</title>
      <link href="/2022/05/30/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E4%B9%8B%E4%BA%AE%E7%82%B9%E4%B8%8E%E9%9A%BE%E7%82%B9/"/>
      <url>/2022/05/30/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E4%B9%8B%E4%BA%AE%E7%82%B9%E4%B8%8E%E9%9A%BE%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>面试中对于项目考察，通常会询问项目中的亮点已经难点。这其实是考察对工作熟悉以及发现并解决问题能力，还有总结归纳的能力。</p><span id="more"></span><h1 id="1-项目亮点"><a href="#1-项目亮点" class="headerlink" title="1.项目亮点"></a>1.项目亮点</h1><p>采用了哪种技术方案，达成了什么样的效果。新方案的优劣势如何？</p><p>比如：</p><ul><li>针对复杂业务根据模块拆分从而更加灵活</li><li>改为无状态服务解耦</li><li>采用订阅发布模型集中维护数据流向，结偶并提升容错和可维护性</li><li>采用了统一网关进行链路追踪方便问题定位以及集中化配置</li><li>采用配置中心提供即时生效的配置更新与完善的权限控制</li><li>统一日志采集提供快速问题定位</li><li>告警系统提供实时邮件提醒</li><li>……</li></ul><h1 id="2-项目难点"><a href="#2-项目难点" class="headerlink" title="2.项目难点"></a>2.项目难点</h1><p>遇到了什么棘手的问题，如何分析定位问题？如果解决？</p><p>比如：</p><ul><li><p>由于MQ失败重试导致的数据错误</p><p>由于MQ一般不会无限重试，所以在对于错误消息会设置延迟重试。此时存在一个问题：如果A，B两笔数据存在依赖关系。这将导致数据不一致。后续我们采用error-callback对于错误数据进行异步修复，并对修复数据集进行监控。</p></li><li><p>JVM方法区OOM</p><p>由于读取配置文件解析时使用的序列化工具内部采用ASM技术动态生成。导致大量Class被加载，最终导致OOM。后续优化方案：配置无需多次加载，对配置进行缓存即可。</p></li><li><p>DNS导致HBase Region不可用</p><p>DNS服务中存在冲突配置导致RegionServer连接异常。排查解决冲突。</p></li><li><p>……</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于项目面试，首先对项目有自己的认识靠清楚几个问题：</p><ul><li>是解决什么问题的？</li><li>是如何解决的？</li><li>解决过程中遇到哪些问题？</li><li>问题产生的原因是什么？</li><li>如果解决遇到问题的？</li><li>为什么这样解决？</li><li>如何减少问题发生的？</li><li>有哪些调优的经验？</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to use hexo</title>
      <link href="/2022/05/29/How-to-use-hexo/"/>
      <url>/2022/05/29/How-to-use-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hexo.io/docs/">https://hexo.io/docs/</a></p><span id="more"></span><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node hexo init blog  <span class="comment"># create dir blog and init</span></span><br><span class="line"><span class="built_in">cd</span> blog </span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>修改_config.yml文件，具体配置项参考文章顶部链接</p><h1 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node hexo clean  <span class="comment"># clean</span></span><br><span class="line">node hexo s  <span class="comment"># start server to preview</span></span><br></pre></td></tr></table></figure><p>修改主题：</p><p>下载主题到theme目录下，修改_config.yml下theme配置即可</p><h1 id="配合github-pages使用"><a href="#配合github-pages使用" class="headerlink" title="配合github pages使用"></a>配合github pages使用</h1><p>_config.yml配置github仓库以及branch</p><p>一键deploy需要安装插件：hexo-github-dploy</p><p>search功能插件：hexo-search-db</p><p>具体参考文章顶部链接</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-mermaid-diagrams  <span class="comment"># markdown mermaid 在主题配置文件中找到mermaid选项，将enable设置为true hexo不支持markdown mermaid渲染. 该插件需要使用直接使用mermaid语法书写</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
